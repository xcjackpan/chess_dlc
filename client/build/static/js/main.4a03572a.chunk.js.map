{"version":3,"sources":["Piece.tsx","Utils.tsx","merida_new/bb.svg","merida_new/bn.svg","merida_new/bp.svg","merida_new/bq.svg","merida_new/bk.svg","merida_new/br.svg","merida_new/wb.svg","merida_new/wn.svg","merida_new/wp.svg","merida_new/wq.svg","merida_new/wk.svg","merida_new/wr.svg","merida_new/we.svg","merida_new/be.svg","Board.tsx","Draft.tsx","Game.tsx","Lobby.tsx","App.tsx","index.js"],"names":["coordinateWithinBoard","coord","validateDiagMove","currPos","newPos","boardState","xDiff","yDiff","Math","abs","xInc","yInc","i","getPieceAt","type","PieceType","NONE","currPiece","targetPiece","oppositeSign","validateCardinalMove","validateCastle","kingPos","rookPos","king","rook","currPlayer","hasMoved","isSquareUnderAttack","getValidKnightMoves","coords","getValidKingMoves","targetSquare","isAttackedByKnight","some","elem","pieceAt","WHITE_KNIGHT","isAttackedByPawn","WHITE_PAWN","isAttackedByKing","WHITE_KING","cardinalAttackers","WHITE_ROOK","WHITE_QUEEN","WHITE_ELEPHANT","isAttackedCardinally","increments","pieceAtType","includes","diagonalAttackers","WHITE_BISHOP","isAttackedDiagonally","Piece","enPassantable","this","Invalid","INVALID","None","Pawn","diff","Bishop","Knight","validKnightMoves","validKnightMove","forEach","squaresEqual","Rook","BLACK_KING","King","validKingMoves","validKingMove","BLACK_ROOK","Queen","isDiag","isCardinal","Elephant","extraInfo","candidate","Object","keys","length","buildPiece","BLACK_PAWN","BLACK_BISHOP","BLACK_KNIGHT","BLACK_QUEEN","BLACK_ELEPHANT","serializePiece","piece","pieceAsJSON","entries","key","value","JSON","stringify","GameState","PlayerType","a","b","squaresContainedBy","arr","target","found","deserializeBoardState","receivedBoardState","parsed","parse","boardToReturn","row","y","pieceAsString","push","pieceAsObject","hasOwnProperty","deserializePiece","flipBoard","deserialized","serializeBoardState","currTurn","checkmate","stalemate","boardToSerialize","serialized","data","processBoard","board","res","slice","reverse","map","renderSquare","selected","onSelect","className","onClick","src","WhiteElephant","BlackElephant","BlackBishop","BlackKing","BlackKnight","BlackPawn","BlackQueen","BlackRook","WhiteBishop","WhiteKing","WhiteKnight","WhitePawn","WhiteQueen","WhiteRook","getAsset","makeMove","oldSquare","newSquare","newBoard","copyPiece","postMovePieces","newRookPos","newKingPos","postMove","x","turnTick","Board","props","currWinner","useState","selectedSquare","setSelectedSquare","displayGameEnd","setDisplayGameEnd","sendToSocket","updateBoardState","Promise","resolve","setTimeout","selectSquare","pieceOnSquare","validateMove","isValidMove","simulatedBoard","opponentKing","allyKing","validateChecks","playerInCheck","opponentInCheck","opponentHasNoValidMoves","validMoves","cardinalIncs","diagonalIncs","piecePos","candidateNewPos","validationResult","every","isOpponentMated","useEffect","Dialog","fullWidth","open","onClose","aria-labelledby","aria-describedby","DialogTitle","DialogActions","Button","occupant","emptyWhiteDraft","emptyBlackDraft","whiteIllegalSquares","blackIllegalSquares","allPieces","pieceToPoints","Draft","submitDraft","currDraft","setCurrDraft","currPoints","setPoints","idx","newDraft","newPointTotal","draftPiece","variant","size","disabled","startingBoard","Game","useCookies","cookies","setCookie","gameId","useLocation","pathname","split","pop","gameState","gameInfo","setGameInfo","webSocket","setWebSocket","cookiePresent","axios","get","params","then","timesJoined","waitingFor","path","maxAge","winner","l","window","location","websocketUrl","protocol","host","ws","WebSocket","onopen","onmessage","event","console","log","updatedGameInfo","draftToSerialize","stringified","post","substring","readyState","send","Lobby","createGame","history","useHistory","style","href","App","isLoading","createdBy","CookiesProvider","render","ReactDOM","StrictMode","document","getElementById"],"mappings":"0QAEA,SAASA,EAAsBC,GAC7B,OAAQA,EAAM,GAAK,GAAKA,EAAM,GAAK,GAAKA,EAAM,IAAM,GAAKA,EAAM,IAAM,EAGvE,SAASC,EAAiBC,EAAqBC,EAAoBC,GACjE,IAAIC,EAAQF,EAAO,GAAKD,EAAQ,GAC5BI,EAAQH,EAAO,GAAKD,EAAQ,GAGhC,KADcK,KAAKC,IAAIH,KAAWE,KAAKC,IAAIF,KACjB,IAAVD,GAAyB,IAAVC,EAC7B,OAAO,EAKT,IAFA,IAAIG,EAAOJ,EAAQ,EAAI,GAAK,EACxBK,EAAOJ,EAAQ,EAAI,GAAK,EACnBK,EAAI,EAAGA,EAAIJ,KAAKC,IAAIH,GAAQM,IAAK,CAExC,GADgBC,EAAW,CAACV,EAAQ,GAAIS,EAAEF,EAAOP,EAAQ,GAAIS,EAAED,GAAQN,GACzDS,OAASC,EAAUC,KAC/B,OAAO,EAIX,IAAIC,EAAYJ,EAAWV,EAASE,GAChCa,EAAcL,EAAWT,EAAQC,GACrC,OAAQa,EAAYJ,OAASC,EAAUC,MAAQG,EAAaD,EAAYJ,KAAMG,EAAUH,MAG1F,SAASM,EAAqBjB,EAAqBC,EAAoBC,GACrE,IAAIC,EAAQF,EAAO,GAAKD,EAAQ,GAC5BI,EAAQH,EAAO,GAAKD,EAAQ,GAGhC,KAD4B,IAAVG,GAAyB,IAAVC,GAA2B,IAAVD,GAAyB,IAAVC,GAE/D,OAAO,EAGT,IAAIG,EAAO,EACPC,EAAO,EAEG,IAAVL,EACFK,EAAOJ,EAAQ,EAAI,GAAK,EAExBG,EAAOJ,EAAQ,EAAI,GAAK,EAG1B,IAAK,IAAIM,EAAI,EAAGA,EAAIJ,KAAKC,IAAIH,GAAQM,IAAK,CAExC,GADgBC,EAAW,CAACV,EAAQ,GAAIS,EAAEF,EAAOP,EAAQ,GAAIS,EAAED,GAAQN,GACzDS,OAASC,EAAUC,KAC/B,OAAO,EAIX,IAAIC,EAAYJ,EAAWV,EAASE,GAChCa,EAAcL,EAAWT,EAAQC,GACrC,OAAQa,EAAYJ,OAASC,EAAUC,MAAQG,EAAaD,EAAYJ,KAAMG,EAAUH,MAG1F,SAASO,EAAeC,EAAqBC,EAAqBlB,GAChE,IAAMmB,EAAOX,EAAWS,EAASjB,GAC3BoB,EAAOZ,EAAWU,EAASlB,GAC3BqB,EAAaF,EAAKV,KAAO,EAAI,GAAK,EAExC,GAAIU,EAAKG,UAAYF,EAAKE,UAAYL,EAAQ,KAAOC,EAAQ,GAC3D,OAAO,EAKT,IAFA,IAAMhB,EAAQgB,EAAQ,GAAKD,EAAQ,GAC7BX,EAAOJ,EAAQ,EAAI,GAAK,EACrBK,EAAI,EAAGA,EAAIJ,KAAKC,IAAIF,GAAQK,IAAK,CAGxC,GAFgBC,EAAW,CAACS,EAAQ,GAAIA,EAAQ,GAAIV,EAAED,GAAQN,GAEhDS,OAASC,EAAUC,KAC/B,OAAO,EAKX,QACEY,EAAoBN,EAASI,EAAYrB,IACtCuB,EAAoB,CAACN,EAAQ,GAAIA,EAAQ,GAAIX,GAAQe,EAAYrB,IACjEuB,EAAoB,CAACN,EAAQ,GAAIA,EAAQ,GAAI,EAAEX,GAAQe,EAAYrB,IAQnE,SAASwB,EAAoBC,GAClC,MAAO,CACL,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,IAIrB,SAASC,EAAkBD,GAChC,MAAO,CACL,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAG,EAAGA,EAAO,GAAG,GACxB,CAACA,EAAO,GAAIA,EAAO,GAAG,GACtB,CAACA,EAAO,GAAG,EAAGA,EAAO,IACrB,CAACA,EAAO,GAAG,EAAGA,EAAO,IACrB,CAACA,EAAO,GAAIA,EAAO,GAAG,IAInB,SAASF,EAAoBI,EAA0BN,EAAoBrB,GAChF,IACM4B,EADsCJ,EAAoBG,GACfE,MAAK,SAACC,GACrD,IAAMC,EAAUvB,EAAWsB,EAAM9B,GACjC,OAASG,KAAKC,IAAI2B,EAAQtB,QAAUC,EAAUsB,cAAiBlB,EAAaiB,EAAQtB,KAAMY,MAOtFY,EAJoC,CACxC,CAACN,EAAa,GAAG,EAAGA,EAAa,GAAG,GACpC,CAACA,EAAa,GAAG,EAAGA,EAAa,GAAG,IAEOE,MAAK,SAACC,GACjD,IAAMC,EAAUvB,EAAWsB,EAAM9B,GACjC,OAASG,KAAKC,IAAI2B,EAAQtB,QAAUC,EAAUwB,YAAepB,EAAaiB,EAAQtB,KAAMY,MAIpFc,EADoCT,EAAkBC,GACfE,MAAK,SAACC,GACjD,IAAMC,EAAUvB,EAAWsB,EAAM9B,GACjC,OAASG,KAAKC,IAAI2B,EAAQtB,QAAUC,EAAU0B,YAAetB,EAAaiB,EAAQtB,KAAMY,MASpFgB,EAAoB,CAExB3B,EAAU4B,WACV5B,EAAU6B,YACV7B,EAAU8B,gBAENC,EAZe,CACnB,CAAC,EAAE,GACH,CAAC,EAAE,GACH,EAAE,EAAE,GACJ,CAAC,GAAG,IAQoCZ,MAAK,SAACa,GAK9C,IAHA,IAAIC,EAAcjC,EAAUC,KACxBN,EAAOqC,EAAW,GAClBpC,EAAOoC,EAAW,GACfC,IAAgBjC,EAAUC,MAC/BgC,EAAcnC,EAAW,CAACmB,EAAa,GAAKtB,EAAMsB,EAAa,GAAKrB,GAAON,GAAYS,KACvFJ,GAAQqC,EAAW,GACnBpC,GAAQoC,EAAW,GAErB,SAAIL,EAAkBO,SAASzC,KAAKC,IAAIuC,MAAiB7B,EAAa6B,EAAatB,OAkC/EwB,EAAoB,CAExBnC,EAAUoC,aACVpC,EAAU6B,aAENQ,EAXe,CACnB,CAAC,EAAE,GACH,EAAE,EAAE,GACJ,CAAC,GAAG,GACJ,EAAE,GAAG,IAOmClB,MAAK,SAACa,GAK9C,IAHA,IAAIC,EAAc,EACdtC,EAAOqC,EAAW,GAClBpC,EAAOoC,EAAW,GACC,IAAhBC,GACLA,EAAcnC,EAAW,CAACmB,EAAa,GAAKtB,EAAMsB,EAAa,GAAKrB,GAAON,GAAYS,KACvFJ,GAAQqC,EAAW,GACnBpC,GAAQoC,EAAW,GAErB,OAAQG,EAAkBD,SAASzC,KAAKC,IAAIuC,KAAiB7B,EAAa6B,EAAatB,MAGzF,OACEc,GACAP,GACAK,GACAQ,GACAM,EAIG,IAAeC,EAcpB,WAAYvC,GAAe,yBAbpBA,UAamB,OAXnBwC,cAAgB,EAWG,KAVnB3B,UAAW,EAWhB4B,KAAKzC,KAAOA,GAKH0C,EAAb,kDAEE,aAAe,uCACPzC,EAAU0C,SAHpB,2DAOI,MAAO,EAAC,EAAO,MAPnB,6EAA6BJ,GAgBhBK,EAAb,kDACE,aAAe,uCACP3C,EAAUC,MAFpB,2DAMI,MAAO,EAAC,EAAO,MANnB,6EAA0BqC,GAcbM,EAAb,kDACE,WAAY7C,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GACpD,IAAKL,EAAsBI,GACzB,MAAO,EAAC,EAAO,IAIjB,GAAID,EAAQ,KAAOC,EAAO,GAAI,CAC5B,GAAID,EAAQ,IAFK,IAESC,EAAO,GAE/B,MAAO,CAACS,EAAWT,EAAQC,GAAYS,OAASC,EAAUC,KAAM,IAC3D,GAAIb,EAAQ,IAAI,IAAYC,EAAO,GAExC,MAAO,CACLS,EAAWT,EAAQC,GAAYS,OAASC,EAAUC,OAC9CuC,KAAK5B,SACR,SAEA,GAAI,CAACxB,EAAQ,GAAG,EAAGA,EAAQ,GAAG,GAAG8C,SAAS7C,EAAO,KAAOD,EAAQ,IAZpD,IAYgEC,EAAO,GAAI,CAE5F,GAAIS,EAAWT,EAAQC,GAAYS,OAASC,EAAUC,MAAQG,EAAaN,EAAWT,EAAQC,GAAYS,KAAMyC,KAAKzC,MACnH,MAAO,EAAC,EAAM,IACT,GAAID,EAAW,CAACT,EAAO,KAhBb,EAgBsBA,EAAO,IAAKC,GAAYS,QAAqB,EAAXyC,KAAKzC,MAAYD,EAAW,CAACT,EAAO,KAhB5F,EAgBqGA,EAAO,IAAKC,GAAYiD,cAAgB,EAC5J,MAAO,EAAC,EAAM,CAAC,WAAa,IAGhC,MAAO,EAAC,EAAO,MA9BnB,+BAiCWnD,EAAqBC,EAAoBC,GAEhD,IAAIuD,EAAeL,KAAKzC,KAAO,GAAK,EAAI,EACpCX,EAAQ,KAAOC,EAAO,IAAMD,EAAQ,GAAI,EAAEyD,IAAUxD,EAAO,KAC7DmD,KAAKD,cAAgB,GAGlBC,KAAK5B,WACR4B,KAAK5B,UAAW,KAzCtB,iCA8CQ4B,KAAKD,cAAgB,IACvBC,KAAKD,eAAiB,OA/C5B,GAA0BD,GAoDbQ,EAAb,kDACE,WAAY/C,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GACpD,OAAKL,EAAsBI,GAGpB,CAACF,EAAiBC,EAASC,EAAQC,GAAa,IAF9C,EAAC,EAAO,MAPrB,iCAaSkD,KAAK5B,WACR4B,KAAK5B,UAAW,KAdtB,yCAA4B0B,GAqBfS,EAAb,kDACE,WAAYhD,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GACpD,IAAKL,EAAsBI,GACzB,MAAO,EAAC,EAAO,IAEjB,IAAI2D,EAAiClC,EAAoB1B,GACrD6D,GAAkB,EAOtB,GANAD,EAAiBE,SAAQ,SAAC9B,GACpB+B,EAAa/B,EAAM/B,KACrB4D,GAAkB,OAIjBA,EACH,MAAO,EAAC,EAAO,IAGjB,IAAI9C,EAAcL,EAAWT,EAAQC,GACrC,MAAO,CAAEa,EAAYJ,OAASC,EAAUC,MAAQG,EAAaD,EAAYJ,KAAMyC,KAAKzC,MAAQ,MAtBhG,iCA0BSyC,KAAK5B,WACR4B,KAAK5B,UAAW,KA3BtB,yCAA4B0B,GAkCfc,EAAb,kDACE,WAAYrD,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GACpD,IAAKL,EAAsBI,GACzB,MAAO,EAAC,EAAO,IAGjB,GAD4BgB,EAAqBjB,EAASC,EAAQC,GAYhE,MAAO,EAAC,EAAM,IATd,IAAIa,EAAcL,EAAWT,EAAQC,GAIrC,OAFGc,EAAaoC,KAAKzC,KAAMI,EAAYJ,QAAUI,EAAYJ,OAASC,EAAU0B,YAAcvB,EAAYJ,OAASC,EAAUqD,YAGpH,CAAE/C,EAAejB,EAAQD,EAASE,GAAc,CAAC,QAAU,EAAM,QAAWD,EAAQ,QAAWD,IAEjG,EAAC,EAAO,MAnBrB,iCA0BSoD,KAAK5B,WACR4B,KAAK5B,UAAW,KA3BtB,yCAA0B0B,GAkCbgB,EAAb,kDACE,WAAYvD,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GACpD,IAAKL,EAAsBI,GACzB,MAAO,EAAC,EAAO,IAEjB,IAAIkE,EAA+BvC,EAAkB5B,GACjDoE,GAAgB,EACpBD,EAAeL,SAAQ,SAAC9B,GAClB+B,EAAa/B,EAAM/B,KACrBmE,GAAgB,MAIpB,IAAIrD,EAAcL,EAAWT,EAAQC,GACrC,OAAKkE,EAUI,CAAErD,EAAYJ,OAASC,EAAUC,MAAQG,EAAaD,EAAYJ,KAAMyC,KAAKzC,MAAQ,KAPzFK,EAAaoC,KAAKzC,KAAMI,EAAYJ,QAAUI,EAAYJ,OAASC,EAAU4B,YAAczB,EAAYJ,OAASC,EAAUyD,YAGpH,CAAEnD,EAAelB,EAASC,EAAQC,GAAc,CAAC,QAAU,EAAM,QAAWF,EAAS,QAAWC,IAElG,EAAC,EAAO,MA1BrB,iCAiCSmD,KAAK5B,WACR4B,KAAK5B,UAAW,KAlCtB,yCAA0B0B,GAyCboB,EAAb,kDACE,WAAY3D,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GACpD,IAAKL,EAAsBI,GACzB,MAAO,EAAC,EAAO,IAEjB,IAAMsE,EAASxE,EAAiBC,EAASC,EAAQC,GAC3CsE,EAAavD,EAAqBjB,EAASC,EAAQC,GACzD,MAAO,CAAEqE,GAAUC,EAAa,MAXpC,iCAeSpB,KAAK5B,WACR4B,KAAK5B,UAAW,KAhBtB,yCAA2B0B,GAuBduB,EAAb,kDACE,WAAY9D,GAAe,uCACnBA,GAFV,yDAKeX,EAAqBC,EAAoBC,GAEpD,IAAKL,EAAsBI,GACzB,MAAO,EAAC,EAAO,IAGjB,IAAIE,EAAQF,EAAO,GAAKD,EAAQ,GAC5BI,EAAQH,EAAO,GAAKD,EAAQ,GAGhC,KAD4B,IAAVG,GAAyB,IAAVC,GAA2B,IAAVD,GAAyB,IAAVC,GAE/D,MAAO,EAAC,EAAO,IAGjB,IAAIG,EAAO,EACPC,EAAO,EAEG,IAAVL,EACFK,EAAOJ,EAAQ,EAAI,GAAK,EAExBG,EAAOJ,EAAQ,EAAI,GAAK,EAI1B,IADA,IAAIuE,EAAiB,GACZjE,EAAI,EAAGA,EAAIJ,KAAKC,IAAIH,GAAQM,IAAK,CACxC,IAAIkE,EAAYjE,EAAW,CAACV,EAAQ,GAAIS,EAAEF,EAAOP,EAAQ,GAAIS,EAAED,GAAQN,GACvE,GAAIyE,EAAUhE,OAASC,EAAUC,MAAQG,EAAa2D,EAAUhE,KAAMyC,KAAKzC,MAAO,CAChF,GAAsC,IAAlCiE,OAAOC,KAAKH,GAAWI,OAEzB,MAAO,EAAC,EAAO,IAEjBJ,EAAY,CAAC,QAAW,CAAC1E,EAAQ,GAAIS,EAAEF,EAAOP,EAAQ,GAAIS,EAAED,SACvD,GAAImE,EAAUhE,OAASC,EAAUC,OAASG,EAAa2D,EAAUhE,KAAMyC,KAAKzC,MACjF,MAAO,EAAC,EAAO,IAInB,IAAIG,EAAYJ,EAAWV,EAASE,GAChCa,EAAcL,EAAWT,EAAQC,GACrC,MAAO,CAAEa,EAAYJ,OAASC,EAAUC,MAAQG,EAAaD,EAAYJ,KAAMG,EAAUH,MAAQ+D,KA5CrG,iCAgDStB,KAAK5B,WACR4B,KAAK5B,UAAW,KAjDtB,yCAA8B0B,GAwDvB,SAAS6B,EAAWpE,GACzB,OAAIA,IAASC,EAAU0C,QACd,IAAID,EACF1C,IAASC,EAAUwB,YAAczB,IAASC,EAAUoE,WACtD,IAAIxB,EAAK7C,GACPA,IAASC,EAAUoC,cAAgBrC,IAASC,EAAUqE,aACxD,IAAIvB,EAAO/C,GACTA,IAASC,EAAUsB,cAAgBvB,IAASC,EAAUsE,aACxD,IAAIvB,EAAOhD,GACTA,IAASC,EAAU4B,YAAc7B,IAASC,EAAUyD,WACtD,IAAIL,EAAKrD,GACPA,IAASC,EAAU0B,YAAc3B,IAASC,EAAUqD,WACtD,IAAIC,EAAKvD,GACPA,IAASC,EAAU6B,aAAe9B,IAASC,EAAUuE,YACvD,IAAIb,EAAM3D,GACRA,IAASC,EAAU8B,gBAAkB/B,IAASC,EAAUwE,eAC1D,IAAIX,EAAS9D,GAEf,IAAI4C,EAgCN,SAAS8B,EAAeC,GAE7B,IADA,IAAIC,EAAsC,GAC1C,MAA2BX,OAAOY,QAAQF,GAA1C,eAAkD,CAAC,IAAD,sBAAtCG,EAAsC,KAAjCC,EAAiC,MACpC,aAARD,GAAuBC,KAGf,kBAARD,GAAqC,IAAVC,IAG/BH,EAAYE,GAAOC,IAGrB,OAAOC,KAAKC,UAAUL,GCnkBjB,IAAMM,GACD,EADCA,EAEI,EAFJA,EAGJ,EAHIA,EAIJ,EAGIC,GACD,IADCA,GAEC,GAFDA,EAGA,EAHAA,EAIJ,EAJIA,GAKH,EAGGlF,EAAY,CACvB0C,SAAU,IACVzC,KAAM,EACNuB,WAAY,EACZF,aAAc,EACdc,aAAc,EACdR,WAAY,EACZC,YAAa,EACbH,WAAY,EACZI,eAAgB,EAChBsC,YAAa,EACbE,cAAe,EACfD,cAAe,EACfZ,YAAa,EACbc,aAAc,EACdlB,YAAa,EACbmB,gBAAiB,GAGZ,SAASrB,EAAagC,EAAeC,GAC1C,OAAOD,EAAE,KAAOC,EAAE,IAAMD,EAAE,KAAOC,EAAE,GAG9B,SAASC,EAAmBC,EAAmBC,GACpD,IAAIC,GAAQ,EAMZ,OALAF,EAAIpC,SAAQ,SAAC9B,GACP+B,EAAa/B,EAAMmE,KACrBC,GAAQ,MAGLA,EAGF,SAAS1F,EAAWZ,EAAmBI,GAC5C,OAAIJ,EAAM,IAAM,GAAKA,EAAM,IAAM,GAAKA,EAAM,GAAK,GAAKA,EAAM,GAAK,EACxDI,EAAWJ,EAAM,IAAIA,EAAM,IAE7BiF,EAAWnE,EAAU0C,SAGvB,SAAStC,EAAa+E,EAAWC,GACtC,OAAU,IAAND,GAAiB,IAANC,IAGRD,EAAI,EAAIC,EAAI,EAAIA,EAAI,G,+EC1Ed,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCA1B,OAA0B,+BCwBlC,SAASK,GAAsBC,EAA4B/E,GAChE,IAAMgF,EAASZ,KAAKa,MAAMF,GACtBG,EAA2B,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAErDF,EAAM,WAAezC,SAAQ,SAAC4C,EAAeC,GAC3CD,EAAI5C,SAAQ,SAAC8C,GACXH,EAAcE,GAAGE,KhBujBhB,SAA0BtB,GAC/B,IAAMuB,EAAgBnB,KAAKa,MAAMjB,GAC7BD,EAAQP,EAAW+B,EAAcnG,MAYrC,OAXImG,EAAcC,eAAe,iBAC/BzB,EAAMnC,cAAgB2D,EAAa,cAEnCxB,EAAMnC,cAAgB,EAGpB2D,EAAcC,eAAe,YAC/BzB,EAAM9D,SAAWsF,EAAa,SAE9BxB,EAAM9D,UAAW,EAEZ8D,EgBrkBmB0B,CAAiBJ,UAIvCrF,IAAeuE,IACjBW,EAAgBQ,GAAUR,IAG5B,IAAIS,EAAoB,CACtB,WAAcT,EACd,SAAYF,EAAM,UAMpB,OAJIA,EAAOQ,eAAe,YACxBG,EAAY,OAAaX,EAAM,QAG1BW,EAGF,SAASC,GAAoBjH,EAAuBkH,EAAkB7F,EAAoB8F,EAAoBC,GAEnH,IAAIC,EAAmBrH,EACnBqB,IAAeuE,IACjByB,EAAmBN,GAAUM,IAE/B,IAAIC,EAAyB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IACnDD,EAAiBzD,SAAQ,SAAC4C,EAAKC,GAC7BD,EAAI5C,SAAQ,SAAC9B,GACXwF,EAAWb,GAAGE,KAAKxB,EAAerD,UAItC,IAAIyF,EAAY,CACd,WAAcD,EACd,SAAYJ,GAQd,OANIC,EACFI,EAAI,OAAalG,EACR+F,IACTG,EAAI,OAAa3B,GAGZH,KAAKC,UAAU6B,GAGjB,SAASC,GAAaC,GAC3B,IAAIC,EAAiB,GAOrB,OANAD,EAAM7D,SAAQ,SAAC4C,EAAKC,GAClBiB,EAAIf,KAAK,IACTH,EAAI5C,SAAQ,SAAC9B,GACX4F,EAAIjB,GAAGE,KAAK9B,EAAW/C,UAGpB4F,EAGF,SAASX,GAAUU,GAExB,OAAOA,EAAME,MAAM,GAAGC,UAAUC,KAAI,SAACrB,GACnC,OAAOA,EAAImB,MAAM,GAAGC,aAIjB,SAASE,GAAalI,EAAmBwF,EAAe2C,EAAmBC,GAmChF,OACE,qBACEC,UAAS,gBAAWF,EAAQ,gBAE5BG,QAAS,WAAKF,EAASpI,IAHzB,SAKE,qBAAKqI,UAAU,QAAQE,IAvC3B,SAAkB/C,GAChB,OAAOA,GACL,KAAK1E,EAAU8B,eACb,OAAO4F,GACT,KAAK1H,EAAUwE,eACb,OAAOmD,GACT,KAAK3H,EAAUqE,aACb,OAAOuD,GACT,KAAK5H,EAAUqD,WACb,OAAOwE,GACT,KAAK7H,EAAUsE,aACb,OAAOwD,GACT,KAAK9H,EAAUoE,WACb,OAAO2D,GACT,KAAK/H,EAAUuE,YACb,OAAOyD,GACT,KAAKhI,EAAUyD,WACb,OAAOwE,GACT,KAAKjI,EAAUoC,aACb,OAAO8F,GACT,KAAKlI,EAAU0B,WACb,OAAOyG,GACT,KAAKnI,EAAUsB,aACb,OAAO8G,GACT,KAAKpI,EAAUwB,WACb,OAAO6G,GACT,KAAKrI,EAAU6B,YACb,OAAOyG,GACT,KAAKtI,EAAU4B,WACb,OAAO2G,IAUmBC,CAAS9D,MALvC,UAEUxF,EAAM,GAFhB,YAEsBA,EAAM,KAQhC,SAASuJ,GAASnJ,EAAuBoJ,EAAuBC,EAAuB7E,GAErF,IAAI8E,EAAsB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAChDtJ,EAAW4D,SAAQ,SAAC4C,EAAKC,GACvBD,EAAI5C,SAAQ,SAAC9B,GACXwH,EAAS7C,GAAGE,KhByZX,SAAmBvB,GAGxB,IAAIsC,EACJ,OAAItC,EAAM3E,OAASC,EAAU0C,QAEpB,IAAID,IAEXuE,EADStC,EAAM3E,OAASC,EAAUwB,YAAckD,EAAM3E,OAASC,EAAUoE,WACnE,IAAIxB,EAAK8B,EAAM3E,MACZ2E,EAAM3E,OAASC,EAAUoC,cAAgBsC,EAAM3E,OAASC,EAAUqE,aACrE,IAAIvB,EAAO4B,EAAM3E,MACd2E,EAAM3E,OAASC,EAAUsB,cAAgBoD,EAAM3E,OAASC,EAAUsE,aACrE,IAAIvB,EAAO2B,EAAM3E,MACd2E,EAAM3E,OAASC,EAAU4B,YAAc8C,EAAM3E,OAASC,EAAUyD,WACnE,IAAIL,EAAKsB,EAAM3E,MACZ2E,EAAM3E,OAASC,EAAU0B,YAAcgD,EAAM3E,OAASC,EAAUqD,WACnE,IAAIC,EAAKoB,EAAM3E,MACZ2E,EAAM3E,OAASC,EAAU6B,aAAe6C,EAAM3E,OAASC,EAAUuE,YACpE,IAAIb,EAAMgB,EAAM3E,MACb2E,EAAM3E,OAASC,EAAU8B,gBAAkB4C,EAAM3E,OAASC,EAAUwE,eACvE,IAAIX,EAASa,EAAM3E,MAEnB,IAAI4C,GAERJ,cAAgBmC,EAAMnC,cAC1ByE,EAAIpG,SAAW8D,EAAM9D,SACdoG,GgBnbc6B,CAAUzH,UAI/B,IAAI0H,EAAiB,GAErB,GAAIhF,EAAUqC,eAAe,WAAarC,EAAS,OAAY,CAC7D,IAAMtD,EAAUsD,EAAS,QACnBvD,EAAUuD,EAAS,QAInBlE,EADQY,EAAQ,GAAKD,EAAQ,GACd,EAAI,GAAK,EAExBwI,EAAa,CAACxI,EAAQ,GAAIA,EAAQ,GAAI,EAAEX,EAAOA,GAC/CoJ,EAAa,CAACzI,EAAQ,GAAIA,EAAQ,GAAI,EAAEX,GAE9CgJ,EAASI,EAAW,IAAIA,EAAW,IAAMlJ,EAAWS,EAASqI,GAC7DA,EAASG,EAAW,IAAIA,EAAW,IAAMjJ,EAAWU,EAASoI,GAE7DE,EAAe7C,KAAK,CAAC1F,EAASyI,IAC9BF,EAAe7C,KAAK,CAACzF,EAASuI,IAE9BH,EAASrI,EAAQ,IAAIA,EAAQ,IAAM4D,EAAWnE,EAAUC,MACxD2I,EAASpI,EAAQ,IAAIA,EAAQ,IAAM2D,EAAWnE,EAAUC,WACnD,GAAI6D,EAAUqC,eAAe,cAAgBrC,EAAS,UAAe,CAC1EgF,EAAe7C,KAAK,CAACyC,EAAWC,IAEhCC,EAASD,EAAU,IAAIA,EAAU,IAAM7I,EAAW4I,EAAWE,GAC7DA,EAASF,EAAU,IAAIA,EAAU,IAAMvE,EAAWnE,EAAUC,MAE5D,IACM4C,EADa/C,EAAW6I,EAAWC,GACjB7I,OAASC,EAAUwB,WAAa,GAAK,EAC7DoH,EAASD,EAAU,GAAG9F,GAAM8F,EAAU,IAAMxE,EAAW,QAEvD2E,EAAe7C,KAAK,CAACyC,EAAWC,IAEhCC,EAASD,EAAU,IAAIA,EAAU,IAAM7I,EAAW4I,EAAWE,GAC7DA,EAASF,EAAU,IAAIA,EAAU,IAAMvE,EAAW,GAoBpD,OAVA2E,EAAe5F,SAAQ,SAAC9B,GACtBwH,EAASxH,EAAK,GAAG,IAAIA,EAAK,GAAG,IAAI6H,SAAS7H,EAAK,GAAIA,EAAK,GAAI9B,MAG9DsJ,EAAS1F,SAAQ,SAAC4C,EAAKC,GACrBD,EAAI5C,SAAQ,SAAC9B,EAAM8H,GACjB9H,EAAK+H,SAAS,CAACD,EAAEnD,GAAI6C,SAIlBA,EAkPMQ,OA/Of,SAAeC,GAAmB,IAC1B1I,EAAqC0I,EAArC1I,WAAY6F,EAAyB6C,EAAzB7C,SAAU8C,EAAeD,EAAfC,WADG,EAGgCC,mBAAS,EAAE,GAAG,IAH9C,mBAGxBC,EAHwB,KAGRC,EAHQ,OAIaF,mBAASrE,GAJtB,mBAIxBwE,EAJwB,KAIRC,EAJQ,mDAU/B,WAAgCf,EAAqBnC,EAAoBC,GAAzE,gBAAAvB,EAAA,sDACQyB,EAAaL,GAAoBqC,GAAoB,EAAVpC,EAAa7F,EAAY8F,EAAWC,GAEjFD,EACFkD,EAAkBhJ,GACT+F,GACTiD,EAAkBzE,GANtB,WAUQmE,EAAMO,aAAahD,GAV3B,uBAWMyC,EAAMQ,iBAAiBjB,GAX7B,4CAcU,IAAIkB,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAAS,MAdrD,mEAV+B,sBAiK/B,SAASE,EAAatB,GAEpB,GAAIxF,EAAawF,EAAWa,GAC1BC,EAAkB,EAAE,GAAI,SAEnB,GAAItG,EAAaqG,EAAgB,EAAE,GAAI,IAC5CC,EAAkBd,OADb,CAMP,IAAMuB,EAAuBb,EAAM/J,WAAWkK,EAAe,IAAIA,EAAe,IAChF,GAAIU,EAAcnK,OAASC,EAAUC,KAArC,CAMA,GADuBuG,IAAa7F,IACdP,EAAa8J,EAAcnK,KAAMY,GAAa,OAEjCuJ,EAAcC,aAAaX,EAAgBb,EAAWU,EAAM/J,YAF3B,mBAE3D8K,EAF2D,KAE9CtG,EAF8C,KAGlE,GAAIsG,EAAa,OA1JrB,SAAwB1F,EAAmBiE,EAAuB7E,GAChE,IAAMuG,EAAiB5B,GAASY,EAAM/J,WAAYoF,EAAOiE,EAAW7E,GAChEwG,EAA2B,EAAE,GAAG,GAChCC,EAAuB,EAAE,GAAG,GAiBhC,OAfAF,EAAenH,SAAQ,SAAC4C,EAAKoD,GAC3BpD,EAAI5C,SAAQ,SAAC9B,EAAM2E,GACb,CAAC/F,EAAUqD,WAAYrD,EAAU0B,YAAYQ,SAASd,EAAKrB,QACzDK,EAAagB,EAAKrB,KAAMY,GAC1B2J,EAAe,CAACpB,EAAGnD,GAEnBwE,EAAW,CAACrB,EAAGnD,UAShB,CAFelF,EAAoB0J,EAAU5J,EAAY0J,GACxCxJ,EAAoByJ,GAAe,EAAE3J,EAAY0J,GACjCA,GAwIeG,CAAehB,EAAgBb,EAAW7E,GAF9E,mBAER2G,EAFQ,KAEOC,EAFP,KAEwB9B,EAFxB,KAGf,IAAK6B,EAAe,CAElB,IAAME,EAxId,SAAyBrL,GACvB,IAAIsL,EAAqB,GACnBC,EAAe,CACnB,CAAC,EAAE,GACH,CAAC,EAAE,GACH,EAAE,EAAE,GACJ,CAAC,GAAG,IAEAC,EAAe,CACnB,CAAC,EAAE,GACH,EAAE,EAAE,GACJ,CAAC,GAAG,GACJ,EAAE,GAAG,IAkFP,OA/EAxL,EAAW4D,SAAQ,SAAC4C,EAAKoD,GACvBpD,EAAI5C,SAAQ,SAAC9B,EAAM2E,GACjB,GAAI3E,EAAKrB,OAASC,EAAUC,MAAQG,EAAaO,EAAYS,EAAKrB,MAAO,CAEvE,IAAMgL,EAAuB,CAAC7B,EAAGnD,GAC3BiF,EAAgC,GAClC,CAAChL,EAAUqD,WAAYrD,EAAU0B,YAAYQ,SAASd,EAAKrB,MACrBiB,EAAkB+J,GACxC7H,SAAQ,SAAC7D,GACzB2L,EAAgB/E,KAAK5G,MAEd,CAACW,EAAUqE,aAAcrE,EAAUoC,cAAcF,SAASd,EAAKrB,MACxE+K,EAAa5H,SAAQ,SAAClB,GAIpB,IAFA,IAAIrC,EAAOqC,EAAW,GAClBpC,EAAOoC,EAAW,GACfvC,KAAKC,IAAIC,IAAS,GAAKF,KAAKC,IAAIE,IAAS,GAC9CoL,EAAgB/E,KAAK,CAACiD,EAAEvJ,EAAMoG,EAAEnG,IAChCD,GAAQqC,EAAW,GACnBpC,GAAQoC,EAAW,MAGd,CAAChC,EAAUsE,aAActE,EAAUsB,cAAcY,SAASd,EAAKrB,MAC9Be,EAAoBiK,GAC1C7H,SAAQ,SAAC7D,GAC3B2L,EAAgB/E,KAAK5G,MAEd,CAACW,EAAUyD,WAAYzD,EAAU4B,YAAYM,SAASd,EAAKrB,MACpE8K,EAAa3H,SAAQ,SAAClB,GAIpB,IAFA,IAAIrC,EAAOqC,EAAW,GAClBpC,EAAOoC,EAAW,GACfvC,KAAKC,IAAIC,IAAS,GAAKF,KAAKC,IAAIE,IAAS,GAC9CoL,EAAgB/E,KAAK,CAACiD,EAAEvJ,EAAMoG,EAAEnG,IAChCD,GAAQqC,EAAW,GACnBpC,GAAQoC,EAAW,MAGd,CAAChC,EAAUuE,YAAavE,EAAU6B,aAAaK,SAASd,EAAKrB,OACtE+K,EAAa5H,SAAQ,SAAClB,GAIpB,IAFA,IAAIrC,EAAOqC,EAAW,GAClBpC,EAAOoC,EAAW,GACfvC,KAAKC,IAAIC,IAAS,GAAKF,KAAKC,IAAIE,IAAS,GAC9CoL,EAAgB/E,KAAK,CAACiD,EAAEvJ,EAAMoG,EAAEnG,IAChCD,GAAQqC,EAAW,GACnBpC,GAAQoC,EAAW,MAIvB6I,EAAa3H,SAAQ,SAAClB,GAIpB,IAFA,IAAIrC,EAAOqC,EAAW,GAClBpC,EAAOoC,EAAW,GACfvC,KAAKC,IAAIC,IAAS,GAAKF,KAAKC,IAAIE,IAAS,GAC9CoL,EAAgB/E,KAAK,CAACiD,EAAEvJ,EAAMoG,EAAEnG,IAChCD,GAAQqC,EAAW,GACnBpC,GAAQoC,EAAW,OAGd,CAAChC,EAAUoE,WAAYpE,EAAUwB,YAAYU,SAASd,EAAKrB,QAEpEiL,EAAgB/E,KAAK,CAACiD,EAAE,EAAGnD,IAC3BiF,EAAgB/E,KAAK,CAACiD,EAAE,EAAGnD,EAAE,IAC7BiF,EAAgB/E,KAAK,CAACiD,EAAE,EAAGnD,EAAE,KAG/BiF,EAAgB9H,SAAQ,SAAC7D,GACvB,IAAM4L,EAAmB7J,EAAK+I,aAAa,CAACjB,EAAEnD,GAAI1G,EAAQC,GACtD2L,EAAiB,IACnBL,EAAW3E,KAAK,CAAC,CAACiD,EAAEnD,GAAI1G,EAAQ4L,EAAiB,eASpDL,EAAWM,OAAM,SAAC9J,GACvB,IAAMiJ,EAAiB5B,GAASnJ,EAAY8B,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAC/DkJ,EAA2B,EAAE,GAAG,GAUpC,OATAD,EAAenH,SAAQ,SAAC4C,EAAKoD,GAC3BpD,EAAI5C,SAAQ,SAAC9B,EAAM2E,GACb,CAAC/F,EAAUqD,WAAYrD,EAAU0B,YAAYQ,SAASd,EAAKrB,OACzDK,EAAagB,EAAKrB,KAAMY,KAC1B2J,EAAe,CAACpB,EAAGnD,UAKpBlF,EAAoByJ,GAAe,EAAE3J,EAAY0J,MA8BpBc,CAAgBvC,GAGhD,OA9LuB,wCA4LvBiB,CAAiBjB,EAAU8B,GAAmBC,GAA0BD,GAAmBC,QAC3FlB,EAAkB,EAAE,GAAI,MAM9BA,EAAkBd,QArBhBc,EAAkBd,IA2BtB,OAnMAyC,qBAAU,WACRzB,EAAkBL,KACjB,CAACA,IAkMF,gCACE,eAAC+B,GAAA,EAAD,CACEC,WAAW,EACXC,KAAM7B,IAAmBxE,EACzBsG,QAAS,WAAO7B,EAAkBzE,IAClCuG,kBAAgB,qBAChBC,mBAAiB,2BALnB,UAOE,cAACC,GAAA,EAAD,UACE,sBAAMpE,UAAU,iBAAhB,SACGmC,IAAmBxE,EAdR,2CAcgDwE,IAAmBxE,EAAmB,QAAU,SAbhG,6BAgBhB,cAAC0G,GAAA,EAAD,UACE,cAACC,GAAA,EAAD,CAAQrE,QAAS,WAAOmC,EAAkBzE,IAA1C,sBAKJ,qBAAKqC,UAAU,QAAf,SACG8B,EAAM/J,WAAW6H,KAChB,SAACrB,EAAKoD,GAAN,OACE,qBAAK3B,UAAU,MAAf,SACGzB,EAAIqB,KAAI,SAAC2E,EAAU/F,GAAX,OAAiBqB,GACxB,CAAC8B,EAAEnD,GACH+F,EAAS/L,KACToD,EAAaqG,EAAgB,CAACN,EAAEnD,IAChCkE,OALsBf,YCvahC6C,I,MAAkB,CACtB,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACf,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAGXC,GAAkB,CACtB,CAAC,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAClB,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,IAKZC,GAAoC,CAAC,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,IAC7DC,GAAoC,CAAC,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,IAc7DC,IANwBnM,EAAUC,KAAMD,EAAU4B,WACxB5B,EAAUC,KAAMD,EAAUoC,aAC1BpC,EAAUC,KAAMD,EAAUsB,aAC3BtB,EAAUC,KAAMD,EAAU6B,YAC3B7B,EAAUC,KAAMD,EAAUwB,WAE5B,CAC1BxB,EAAUC,KACVD,EAAU4B,WACV5B,EAAUoC,aACVpC,EAAUsB,aACVtB,EAAU6B,YACV7B,EAAUwB,aAGZ,SAAS4K,GAAc1H,GACrB,OAAOA,GACL,KAAK1E,EAAUqE,aACb,OAAO,EACT,KAAKrE,EAAUqD,WACb,OAAO,EACT,KAAKrD,EAAUsE,aACb,OAAO,EACT,KAAKtE,EAAUoE,WACb,OAAO,EACT,KAAKpE,EAAUuE,YACb,OAAO,EACT,KAAKvE,EAAUyD,WACb,OAAO,EACT,KAAKzD,EAAUoC,aACb,OAAO,EACT,KAAKpC,EAAU0B,WACb,OAAO,EACT,KAAK1B,EAAUsB,aACb,OAAO,EACT,KAAKtB,EAAUwB,WACb,OAAO,EACT,KAAKxB,EAAU6B,YACb,OAAO,EACT,KAAK7B,EAAU4B,WACb,OAAO,EACT,KAAK5B,EAAU8B,eAEf,KAAK9B,EAAUwE,eACb,OAAO,EAEX,OAAO,EA0IM6H,OAvIf,SAAehD,GAAa,IACpB1I,EAA4B0I,EAA5B1I,WAAY2L,EAAgBjD,EAAhBiD,YADO,EAE4B/C,mBAAS5I,IAAeuE,EAAmB8G,GAAkBD,IAFzF,mBAElBQ,EAFkB,KAEPC,EAFO,OAGsBjD,mBA/D9B,IA4DQ,mBAGlBkD,EAHkB,KAGNC,EAHM,OAIsCnD,mBAAS,EAAE,GAAG,IAJpD,mBAIlBC,EAJkB,KAIFC,EAJE,KAMzB,SAASQ,EAAatB,GAChBhI,IAAeuE,IAIf/B,EAAawF,EAAWa,GAC1BC,EAAkB,EAAE,GAAI,IAI1BA,EAAkBd,IAwDpB,OACE,sBAAKpB,UAAU,QAAf,UACE,qBAAKA,UAAU,cAAf,SACGgF,EAAUpF,KACT,SAACrB,EAAKoD,GAAN,OACE,qBAAK3B,UAAU,MAAf,SACGzB,EAAIqB,KAAI,SAAC2E,EAAU/F,GAAX,OAAiBqB,GACxB,CAAC8B,EAAEnD,GACH+F,EACA3I,EAAaqG,EAAgB,CAACN,EAAEnD,IAChCkE,OALsBf,QAWhC,qBAAK3B,UAAU,mBAAf,SACE,qBAAKA,UAAU,MAAf,UAlEFpE,EAAaqG,EAAgB,EAAE,GAAI,KAC/B7I,IAAeuE,GAAoBG,EAAmB4G,GAAqBzC,IAC3E7I,IAAeuE,GAAoBG,EAAmB6G,GAAqB1C,GAExE,GAEC2C,GAqBChF,KAAI,SAAC/F,GAAD,OAAUT,EAAWS,MAwCX+F,KACjB,SAACzC,EAAOiI,GACN,OAAOvF,GACL,EAAE,EAAEuF,GACJjI,EACAvB,EAAaqG,EAAgB,EAAE,EAAEmD,KACjC,YA3Cd,SAAoBjI,GAClB,IAAIkI,EAAuB,CAAC,GAAG,IAC3BC,EAnHW,GAoHfN,EAAUrJ,SAAQ,SAAC4C,EAAKC,GACtBD,EAAI5C,SAAQ,SAAC9B,EAAM8H,GACb/F,EAAaqG,EAAgB,CAACzD,EAAEmD,KAClC0D,EAAS7G,GAAGE,KAAKvB,GACjBmI,GAAiBT,GAAc1H,KAE/BkI,EAAS7G,GAAGE,KAAK7E,GACjByL,GAAiBT,GAAchL,UAKrCoL,EAAaI,GACbF,EAAUG,GA2BSC,CAAWpI,aAO5B,sBAAK6C,UAAU,oBAAf,UACE,qBAAKA,UAAU,SAAf,SAAwB,iCAASkF,MACjC,cAACZ,GAAA,EAAD,CAAQkB,QAAQ,YAAYC,KAAK,QAAQC,SAAUtM,IAAeuE,EAAsBsC,QAAS,kBAAM8E,EAAYC,EAAWE,IAA9H,SACE,sBAAMlF,UAAU,cAAhB,+BAIJ,uBAEA,sBAAKA,UAAU,OAAf,UACE,8JAKA,8OAKA,yDAEE,+BACE,+BAAI,+FAAJ,gEACA,6BAAI,oIC/LV2F,GAAgB,CACpB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GACvB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GACvB,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACf,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACf,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACf,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACf,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GACf,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAiLFC,OAnKf,WAAgB,MAM6BC,YAAW,CAAC,cANzC,mBAMPC,EANO,KAMEC,EANF,aAOkB/D,mBAAS,CACvCgE,OAAQC,cAAcC,SAASC,MAAM,KAAKC,MAC1CC,UAAW3I,EACXtE,WAAYuE,EACZsB,SAAUtB,EACVoE,WAAYpE,EACZ5F,WAAYwH,GAAaoG,OAbb,mBAOPW,EAPO,KAOGC,EAPH,OAegCvE,mBAAS,MAfzC,mBAePwE,EAfO,KAeIC,EAfJ,KAyId,OAxHA5C,qBAAU,WAKR,IAAM6C,EAAgBZ,EAAQlH,eAAe,cAAgBkH,EAAQ,aAAalH,eAAe,UACjG+H,IAAMC,IAAN,gBAAmBN,EAASN,QAAU,CAACa,OAAQ,CAACH,cAAeA,KAAiBI,MAAK,SAAArH,GACnF,IAAIrG,EAAauE,EAejB,GAdI+I,EAEFtN,EAAa0M,EAAQ,aAAR,OACJrG,EAAIH,KAAKyH,aAAe,IAEjC3N,EAAaqG,EAAIH,KAAK0H,WAEtBjB,EACE,YACA,CAAC,OAAUtG,EAAIH,KAAK0H,WAAY,OAAUV,EAASN,QACnD,CAACiB,KAAK,SAAD,OAAWX,EAASN,QAAUkB,OAAQ,UAI3CzH,EAAIH,KAAKE,MAAO,CAClB,IAAMrB,EAAqBD,GAAsBuB,EAAIH,KAAKE,MAAOpG,GACjEmN,EAAY,2BACPD,GADM,IAETlN,WAAYA,EACZ4M,OAAQM,EAASN,OACjBK,UAAW5G,EAAIH,KAAK+G,UACpBtO,WAAYoG,EAAmBpG,WAC/BkH,SAAUd,EAAmBc,SAC7B8C,WAAY5D,EAAmBS,eAAe,UAAYT,EAAmBgJ,OAASxJ,UAIxF4I,EAAY,2BACPD,GADM,IAETlN,WAAYA,EACZ4M,OAAQM,EAASN,OACjBK,UAAW5G,EAAIH,KAAK+G,UACpBpH,SAAUtB,KAKd,IAAMyJ,EAAIC,OAAOC,SACbC,GAAgC,WAAfH,EAAEI,SAAyB,SAAW,SAAWJ,EAAEK,KAArD,qBAA0EnB,EAASN,QAElG0B,EAAK,IAAIC,UAAUJ,GACvBG,EAAGE,OAAS,WACVnB,EAAaiB,IAMfA,EAAGG,UAAY,SAACC,GAEdvB,GAAY,SAACD,GACX,IAAMnI,EAAqBD,GAAsB4J,EAAMxI,KAAMgH,EAASlN,YACtE2O,QAAQC,IAAI7J,GACZ,IAAM8J,EAAe,2BAChB3B,GADgB,IAEnBD,UAAW3I,EACX3F,WAAYoG,EAAmBpG,WAC/BkH,SAAUd,EAAmBc,SAC7B8C,WAAY5D,EAAmBS,eAAe,UAAYT,EAAmBgJ,OAASxJ,IAGxF,OADAoK,QAAQC,IAAIC,GACLA,WAIZ,IA+CC3B,EAASD,YAAc3I,EAClB,6CAEE4I,EAASD,YAAc3I,GAAmB4I,EAASD,YAAc3I,EAExE,cAAC,GAAD,CACEtE,WAAYkN,EAASlN,WACrB2L,YA3CN,SAAqBC,EAAuBE,GAC1C,KAAIA,EAAa,GAAjB,CAMA,IAEIgD,EAFqB3I,GAAayF,GAGlCsB,EAASlN,aAAeuE,IAC1BuK,EAAmBpJ,GAAUoJ,IAE/B,IAAI7I,EAAyB,GAC7B6I,EAAiBvM,SAAQ,SAAC4C,EAAKC,GAC7Ba,EAAWX,KAAK,IAChBH,EAAI5C,SAAQ,SAAC9B,GACXwF,EAAWb,GAAGE,KAAKxB,EAAerD,UAItC,IAAMsO,EAAc3K,KAAKC,UAAU4B,GACnCsH,IAAMyB,KAAN,iBACY9B,EAASN,QACnB,CAAC,WAAcM,EAASlN,WAAY,MAAS+O,EAAYE,UAAU,EAAGF,EAAYxL,OAAO,SAyBzF,cAAC,GAAD,CACE5E,WAAYuO,EAASvO,WACrBqB,WAAYkN,EAASlN,WACrB6F,SAAUqH,EAASrH,SACnB8C,WAAYuE,EAASvE,WACrBM,aA/DN,SAAsB/C,GACpB,OAAkB,OAAdkH,GAA+C,IAAzBA,EAAU8B,aAGlC9B,EAAU+B,KAAKjJ,IACR,IA2DLgD,iBA3BN,SAA0BjB,GACxBkF,EAAY,2BACPD,GADM,IAETrH,UAAW,EAAEqH,EAASrH,SACtBlH,WAAYsJ,S,MCtHHmH,OA5Cf,SAAe1G,GAAa,IAClB2G,EAAe3G,EAAf2G,WACFC,EAAUC,cAEhB,OACE,sBAAK3I,UAAU,QAAf,UACE,sBAAKA,UAAU,OAAf,UACE,4BACE,kDAAoB,sBAAM4I,MAAO,CAAC,SAAY,QAA1B,sCAGtB,iFACkD,mBAAGC,KAAK,8CAAR,2BADlD,yEAGE,+BACE,+BAAI,4CAAJ,kEACA,+BAAI,2CAAJ,gFAIJ,8BACE,mDADF,sKAKA,8BACE,iDADF,kNAKA,4BAAG,mBAAGA,KAAK,yCAAR,0DAEL,sBAAK7I,UAAU,UAAf,UACE,cAACsE,GAAA,EAAD,CAAQkB,QAAQ,YAAYC,KAAK,QAAQxF,QAAS,WAAOwI,EAAWC,EAAS/K,IAA7E,SACE,sBAAMqC,UAAU,cAAhB,oCAEF,cAACsE,GAAA,EAAD,CAAQkB,QAAQ,YAAYC,KAAK,QAAQxF,QAAS,WAAOwI,EAAWC,EAAS/K,IAA7E,SACE,sBAAMqC,UAAU,cAAhB,2CCaK8I,OAhDf,WAAgB,IAAD,EACqB9G,oBAAS,GAD9B,mBACN+G,EADM,KAGb,SAASN,EAAWC,EAAcM,GAEhCrC,IAAMyB,KAAK,UAAW,CAAC,UAAaY,IAAYlC,MAAK,SAAArH,GACnD,IAAM6G,EAAW7G,EAAIH,KAGrBoJ,EAAQhK,KAAR,gBAAsB4H,EAASN,YAInC,OAba,KAaT+C,EAEA,qBAAK/I,UAAU,OAAf,SACE,4CAKF,cAACiJ,EAAA,EAAD,UACE,cAAC,IAAD,UACE,eAAC,IAAD,WACE,cAAC,IAAD,CACEhC,KAAK,gBACLiC,OAAQ,kBACN,qBAAKlJ,UAAU,OAAf,SACE,cAAC,GAAD,SAIN,cAAC,IAAD,CACEkJ,OAAQ,kBACN,qBAAKlJ,UAAU,OAAf,SACE,cAAC,GAAD,CACEyI,WAAYA,iBCtChCU,IAASD,OACP,cAAC,IAAME,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,U","file":"static/js/main.4a03572a.chunk.js","sourcesContent":["import { PieceType, squaresEqual, oppositeSign, getPieceAt, coordinate } from \"./Utils\";\n\nfunction coordinateWithinBoard(coord: coordinate) {\n  return (coord[0] < 8 && coord[1] < 8 && coord[0] >= 0 && coord[1] >= 0)\n}\n\nfunction validateDiagMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]): boolean {\n  let xDiff = newPos[0] - currPos[0]\n  let yDiff = newPos[1] - currPos[1]\n\n  let onDiag = (Math.abs(xDiff) === Math.abs(yDiff))\n  if (!onDiag || (xDiff === 0 || yDiff === 0)) {\n    return false\n  }\n\n  let xInc = xDiff > 0 ? 1 : -1\n  let yInc = yDiff > 0 ? 1 : -1\n  for (let i = 1; i < Math.abs(xDiff); i++) {\n    let candidate = getPieceAt([currPos[0]+(i*xInc), currPos[1]+(i*yInc)], boardState)\n    if (candidate.type !== PieceType.NONE) {\n      return false\n    }\n  }\n\n  let currPiece = getPieceAt(currPos, boardState)\n  let targetPiece = getPieceAt(newPos, boardState)\n  return (targetPiece.type === PieceType.NONE || oppositeSign(targetPiece.type, currPiece.type))\n}\n\nfunction validateCardinalMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]): boolean {\n  let xDiff = newPos[0] - currPos[0]\n  let yDiff = newPos[1] - currPos[1]\n\n  let onCardinal = (xDiff === 0 && yDiff !== 0) || (xDiff !== 0 && yDiff === 0)\n  if (!onCardinal) {\n    return false\n  }\n\n  let xInc = 0\n  let yInc = 0\n\n  if (xDiff === 0) {\n    yInc = yDiff > 0 ? 1 : -1\n  } else {\n    xInc = xDiff > 0 ? 1 : -1\n  }\n\n  for (let i = 1; i < Math.abs(xDiff); i++) {\n    let candidate = getPieceAt([currPos[0]+(i*xInc), currPos[1]+(i*yInc)], boardState)\n    if (candidate.type !== PieceType.NONE) {\n      return false\n    }\n  }\n\n  let currPiece = getPieceAt(currPos, boardState)\n  let targetPiece = getPieceAt(newPos, boardState)\n  return (targetPiece.type === PieceType.NONE || oppositeSign(targetPiece.type, currPiece.type))\n}\n\nfunction validateCastle(kingPos: coordinate, rookPos: coordinate, boardState: Piece[][]): boolean {\n  const king = getPieceAt(kingPos, boardState)\n  const rook = getPieceAt(rookPos, boardState)\n  const currPlayer = king.type > 0 ? 1 : -1\n\n  if (king.hasMoved || rook.hasMoved || kingPos[0] !== rookPos[0]) {\n    return false\n  }\n\n  const yDiff = rookPos[1] - kingPos[1]\n  const yInc = yDiff > 0 ? 1 : -1\n  for (let i = 1; i < Math.abs(yDiff); i++) {\n    let candidate = getPieceAt([kingPos[0], kingPos[1]+(i*yInc)], boardState)\n\n    if (candidate.type !== PieceType.NONE) {\n      return false\n    }\n  }\n\n  // Can't castle while in check or through check\n  if (\n    isSquareUnderAttack(kingPos, currPlayer, boardState)\n    || isSquareUnderAttack([kingPos[0], kingPos[1]+(yInc)], currPlayer, boardState)\n    || isSquareUnderAttack([kingPos[0], kingPos[1]+(2*yInc)], currPlayer, boardState)\n  ) {\n    return false\n  }\n\n  return true\n}\n\nexport function getValidKnightMoves(coords: coordinate): coordinate[] {\n  return [\n    [coords[0]-1, coords[1]-2],\n    [coords[0]+1, coords[1]-2],\n    [coords[0]-1, coords[1]+2],\n    [coords[0]+1, coords[1]+2],\n    [coords[0]-2, coords[1]-1],\n    [coords[0]+2, coords[1]-1],\n    [coords[0]-2, coords[1]+1],\n    [coords[0]+2, coords[1]+1],\n  ]\n}\n\nexport function getValidKingMoves(coords: coordinate): coordinate[] {\n  return [\n    [coords[0]-1, coords[1]-1],\n    [coords[0]+1, coords[1]-1],\n    [coords[0]-1, coords[1]+1],\n    [coords[0]+1, coords[1]+1],\n    [coords[0], coords[1]-1],\n    [coords[0]+1, coords[1]],\n    [coords[0]-1, coords[1]],\n    [coords[0], coords[1]+1],\n  ]\n}\n\nexport function isSquareUnderAttack(targetSquare: coordinate, currPlayer: number, boardState: Piece[][]) {\n  const validAttackingKnights: coordinate[] = getValidKnightMoves(targetSquare)\n  const isAttackedByKnight = validAttackingKnights.some((elem) => {\n    const pieceAt = getPieceAt(elem, boardState)\n    return ((Math.abs(pieceAt.type) === PieceType.WHITE_KNIGHT) && oppositeSign(pieceAt.type, currPlayer))\n  })\n\n  const validAttackingPawns: coordinate[] = [\n    [targetSquare[0]-1, targetSquare[1]-1],\n    [targetSquare[0]-1, targetSquare[1]+1],\n  ]\n  const isAttackedByPawn = validAttackingPawns.some((elem) => {\n    const pieceAt = getPieceAt(elem, boardState)\n    return ((Math.abs(pieceAt.type) === PieceType.WHITE_PAWN) && oppositeSign(pieceAt.type, currPlayer))\n  })\n\n  const validAttackingKings: coordinate[] = getValidKingMoves(targetSquare)\n  const isAttackedByKing = validAttackingKings.some((elem) => {\n    const pieceAt = getPieceAt(elem, boardState)\n    return ((Math.abs(pieceAt.type) === PieceType.WHITE_KING) && oppositeSign(pieceAt.type, currPlayer))\n  })\n\n  const cardinalIncs = [\n    [1,0],\n    [0,1],\n    [-1,0],\n    [0,-1]\n  ]\n  const cardinalAttackers = [\n    // Use WHITE pieces since we're absolute valuing\n    PieceType.WHITE_ROOK,\n    PieceType.WHITE_QUEEN,\n    PieceType.WHITE_ELEPHANT,\n  ]\n  const isAttackedCardinally = cardinalIncs.some((increments) => {\n    // Increments is an [xInc, yInc]\n    let pieceAtType = PieceType.NONE\n    let xInc = increments[0]\n    let yInc = increments[1]\n    while (pieceAtType === PieceType.NONE) {\n      pieceAtType = getPieceAt([targetSquare[0] + xInc, targetSquare[1] + yInc], boardState).type\n      xInc += increments[0]\n      yInc += increments[1]\n    }\n    if (cardinalAttackers.includes(Math.abs(pieceAtType)) && oppositeSign(pieceAtType, currPlayer)) {\n      return true\n    }\n\n    /*\n    TODO: Elephant\n    if (pieceAtType !== PieceType.INVALID && oppositeSign(pieceAtType, currPlayer)) {\n      // Elephant cannot crush its own piece\n      return false\n    } else if (pieceAtType !== PieceType.INVALID) {\n      pieceAtType = getPieceAt([targetSquare[0] + xInc, targetSquare[1] + yInc], boardState).type\n      while (pieceAtType === PieceType.NONE) {\n        xInc += increments[0]\n        yInc += increments[1]\n        pieceAtType = getPieceAt([targetSquare[0] + xInc, targetSquare[1] + yInc], boardState).type\n      }\n\n      if ([PieceType.BLACK_ELEPHANT, PieceType.WHITE_ELEPHANT].includes(pieceAtType) && oppositeSign(pieceAtType, currPlayer)) {\n        // Is an opposing elephant\n        return true\n      }\n    }\n    // Check if the elephant can deliver a mate through crush\n    */\n\n    return false\n  })\n\n  const diagonalIncs = [\n    [1,1],\n    [-1,1],\n    [1,-1],\n    [-1,-1]\n  ]\n  const diagonalAttackers = [\n    // Use WHITE pieces since we're absolute valuing\n    PieceType.WHITE_BISHOP,\n    PieceType.WHITE_QUEEN,\n  ]\n  const isAttackedDiagonally = diagonalIncs.some((increments) => {\n    // Increments is an [xInc, yInc]\n    let pieceAtType = 0\n    let xInc = increments[0]\n    let yInc = increments[1]\n    while (pieceAtType === 0) {\n      pieceAtType = getPieceAt([targetSquare[0] + xInc, targetSquare[1] + yInc], boardState).type\n      xInc += increments[0]\n      yInc += increments[1]\n    }\n    return (diagonalAttackers.includes(Math.abs(pieceAtType)) && oppositeSign(pieceAtType, currPlayer))\n  })\n\n  return (\n    isAttackedByKing ||\n    isAttackedByKnight ||\n    isAttackedByPawn ||\n    isAttackedCardinally ||\n    isAttackedDiagonally\n  )\n}\n\nexport abstract class Piece {\n  public type: number;\n\n  public enPassantable = 0;\n  public hasMoved = false;\n\n  abstract validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]): any[];\n\n  // Called after this piece moves\n  abstract postMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]): any;\n\n  // Called after a turn ticks\n  abstract turnTick(currPos: coordinate, boardState: Piece[][]): any;\n\n  constructor(type: number) {\n    this.type = type\n  }\n}\n\n\nexport class Invalid extends Piece {\n  // For board boundaries\n  constructor() {\n    super(PieceType.INVALID)\n  }\n\n  validateMove() {\n    return [false, {}];\n  }\n\n  postMove() {}\n\n  turnTick() {}\n}\n\n\nexport class None extends Piece {\n  constructor() {\n    super(PieceType.NONE)\n  }\n\n  validateMove() {\n    return [false, {}];\n  }\n\n  postMove() {}\n\n  turnTick() {}\n}\n\nexport class Pawn extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n    // TODO: diff = -1 means pawns moving from White's perspective\n    let diff: number = -1\n    if (currPos[1] === newPos[1]) {\n      if (currPos[0]+(diff) === newPos[0]) {\n        // Moving one square forward valid only when square empty\n        return [getPieceAt(newPos, boardState).type === PieceType.NONE, {}]\n      } else if (currPos[0]+(2*diff) === newPos[0]) {\n        // Moving two squares valid only when on starting square\n        return [(\n          getPieceAt(newPos, boardState).type === PieceType.NONE\n          && !this.hasMoved\n        ), {}]\n      }\n    } else if ([currPos[1]-1, currPos[1]+1].includes(newPos[1]) && currPos[0]+diff === newPos[0]) {\n      // Capture\n      if (getPieceAt(newPos, boardState).type !== PieceType.NONE && oppositeSign(getPieceAt(newPos, boardState).type, this.type)) {\n        return [true, {}]\n      } else if (getPieceAt([newPos[0]-diff, newPos[1]], boardState).type === (this.type*-1) && getPieceAt([newPos[0]-diff, newPos[1]], boardState).enPassantable > 0) {\n        return [true, {\"enpassant\": true}]\n      }\n    }\n    return [false, {}]\n  }\n\n  postMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    // TODO: Handle promotion\n    let diff: number = this.type > 0 ? -1 : 1\n    if (currPos[1] === newPos[1] && currPos[0]+(2*diff) === newPos[0]) {\n      this.enPassantable = 2\n    }\n\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {\n    if (this.enPassantable > 0) {\n      this.enPassantable -= 1\n    }\n  }\n}\n\nexport class Bishop extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n    return [validateDiagMove(currPos, newPos, boardState), {}]\n  }\n\n  postMove() {\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {}\n}\n\nexport class Knight extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n    let validKnightMoves: coordinate[] = getValidKnightMoves(currPos)\n    let validKnightMove = false\n    validKnightMoves.forEach((elem) => {\n      if (squaresEqual(elem, newPos)) {\n        validKnightMove = true\n      }\n    })\n\n    if (!validKnightMove) {\n      return [false, {}]\n    }\n\n    let targetPiece = getPieceAt(newPos, boardState)\n    return [(targetPiece.type === PieceType.NONE || oppositeSign(targetPiece.type, this.type)), {}]\n  }\n\n  postMove() {\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {}\n}\n\nexport class Rook extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n    const isValidCardinalMove = validateCardinalMove(currPos, newPos, boardState)\n    if (!isValidCardinalMove) {\n      // Check castling\n      let targetPiece = getPieceAt(newPos, boardState)\n      const isTargetFriendlyKing = (\n        !oppositeSign(this.type, targetPiece.type) && (targetPiece.type === PieceType.WHITE_KING || targetPiece.type === PieceType.BLACK_KING)\n      )\n      if (isTargetFriendlyKing) {\n        return [(validateCastle(newPos, currPos, boardState)), {\"castle\": true, \"kingPos\": newPos, \"rookPos\": currPos}]\n      }\n      return [false, {}]\n    } else {\n      return [true, {}]\n    }\n  }\n\n  postMove() {\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {}\n}\n\nexport class King extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n    let validKingMoves: coordinate[] = getValidKingMoves(currPos)\n    let validKingMove = false\n    validKingMoves.forEach((elem) => {\n      if (squaresEqual(elem, newPos)) {\n        validKingMove = true\n      }\n    })\n\n    let targetPiece = getPieceAt(newPos, boardState)\n    if (!validKingMove) {\n      // Check castling\n      const isTargetFriendlyRook = (\n        !oppositeSign(this.type, targetPiece.type) && (targetPiece.type === PieceType.WHITE_ROOK || targetPiece.type === PieceType.BLACK_ROOK)\n      )\n      if (isTargetFriendlyRook) {\n        return [(validateCastle(currPos, newPos, boardState)), {\"castle\": true, \"kingPos\": currPos, \"rookPos\": newPos}]\n      }\n      return [false, {}]\n    } else {\n      return [(targetPiece.type === PieceType.NONE || oppositeSign(targetPiece.type, this.type)), {}]\n    }\n  }\n\n  postMove() {\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {}\n}\n\nexport class Queen extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n    const isDiag = validateDiagMove(currPos, newPos, boardState)\n    const isCardinal = validateCardinalMove(currPos, newPos, boardState)\n    return [(isDiag || isCardinal), {}];\n  }\n\n  postMove() {\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {}\n}\n\nexport class Elephant extends Piece {\n  constructor(type: number) {\n    super(type)\n  }\n\n  validateMove(currPos: coordinate, newPos: coordinate, boardState: Piece[][]) {\n    // The elephant is a rook with the \"crush\" ability\n    if (!coordinateWithinBoard(newPos)) {\n      return [false, {}]\n    }\n\n    let xDiff = newPos[0] - currPos[0]\n    let yDiff = newPos[1] - currPos[1]\n  \n    let onCardinal = (xDiff === 0 && yDiff !== 0) || (xDiff !== 0 && yDiff === 0)\n    if (!onCardinal) {\n      return [false, {}]\n    }\n  \n    let xInc = 0\n    let yInc = 0\n  \n    if (xDiff === 0) {\n      yInc = yDiff > 0 ? 1 : -1\n    } else {\n      xInc = xDiff > 0 ? 1 : -1\n    }\n  \n    let extraInfo: any = {}\n    for (let i = 1; i < Math.abs(xDiff); i++) {\n      let candidate = getPieceAt([currPos[0]+(i*xInc), currPos[1]+(i*yInc)], boardState)\n      if (candidate.type !== PieceType.NONE && oppositeSign(candidate.type, this.type)) {\n        if (Object.keys(extraInfo).length !== 0) {\n          // If we've already crushed something, we can't crush again\n          return [false, {}]\n        }\n        extraInfo = {\"crushed\": [currPos[0]+(i*xInc), currPos[1]+(i*yInc)]}\n      } else if (candidate.type !== PieceType.NONE && !oppositeSign(candidate.type, this.type)) {\n        return [false, {}]\n      }\n    }\n  \n    let currPiece = getPieceAt(currPos, boardState)\n    let targetPiece = getPieceAt(newPos, boardState)\n    return [(targetPiece.type === PieceType.NONE || oppositeSign(targetPiece.type, currPiece.type)), extraInfo]\n  }\n\n  postMove() {\n    if (!this.hasMoved) {\n      this.hasMoved = true\n    }\n  }\n\n  turnTick() {}\n}\n\nexport function buildPiece(type: number) {\n  if (type === PieceType.INVALID) {\n    return new Invalid()\n  } else if (type === PieceType.WHITE_PAWN || type === PieceType.BLACK_PAWN) {\n    return new Pawn(type)\n  } else if (type === PieceType.WHITE_BISHOP || type === PieceType.BLACK_BISHOP) {\n    return new Bishop(type)\n  } else if (type === PieceType.WHITE_KNIGHT || type === PieceType.BLACK_KNIGHT) {\n    return new Knight(type)\n  } else if (type === PieceType.WHITE_ROOK || type === PieceType.BLACK_ROOK) {\n    return new Rook(type)\n  } else if (type === PieceType.WHITE_KING || type === PieceType.BLACK_KING) {\n    return new King(type)\n  } else if (type === PieceType.WHITE_QUEEN || type === PieceType.BLACK_QUEEN) {\n    return new Queen(type)\n  } else if (type === PieceType.WHITE_ELEPHANT || type === PieceType.BLACK_ELEPHANT) {\n    return new Elephant(type)\n  }\n  return new None()\n}\n\nexport function copyPiece(piece: Piece) {\n  // For now, this is pretty similar to buildPiece but will copy\n  // properties specific to the piece (ie. counters)\n  let res\n  if (piece.type === PieceType.INVALID) {\n    // TODO: Should never happen\n    return new Invalid()\n  } else if (piece.type === PieceType.WHITE_PAWN || piece.type === PieceType.BLACK_PAWN) {\n    res = new Pawn(piece.type)\n  } else if (piece.type === PieceType.WHITE_BISHOP || piece.type === PieceType.BLACK_BISHOP) {\n    res = new Bishop(piece.type)\n  } else if (piece.type === PieceType.WHITE_KNIGHT || piece.type === PieceType.BLACK_KNIGHT) {\n    res = new Knight(piece.type)\n  } else if (piece.type === PieceType.WHITE_ROOK || piece.type === PieceType.BLACK_ROOK) {\n    res = new Rook(piece.type)\n  } else if (piece.type === PieceType.WHITE_KING || piece.type === PieceType.BLACK_KING) {\n    res = new King(piece.type)\n  } else if (piece.type === PieceType.WHITE_QUEEN || piece.type === PieceType.BLACK_QUEEN) {\n    res = new Queen(piece.type)\n  } else if (piece.type === PieceType.WHITE_ELEPHANT || piece.type === PieceType.BLACK_ELEPHANT) {\n    res = new Elephant(piece.type)\n  } else {\n    res = new None()\n  }\n  res.enPassantable = piece.enPassantable\n  res.hasMoved = piece.hasMoved\n  return res\n}\n\nexport function serializePiece(piece: Piece) {\n  let pieceAsJSON: {[key:string]: string} = {}\n  for (const [key, value] of Object.entries(piece)) {\n    if (key === \"hasMoved\" && !value) {\n      continue\n    }\n    if (key === \"enPassantable\" && value === 0) {\n      continue\n    }\n    pieceAsJSON[key] = value\n  }\n\n  return JSON.stringify(pieceAsJSON)\n}\n\nexport function deserializePiece(pieceAsJSON: string) {\n  const pieceAsObject = JSON.parse(pieceAsJSON)\n  let piece = buildPiece(pieceAsObject.type)\n  if (pieceAsObject.hasOwnProperty(\"enPassantable\")) {\n    piece.enPassantable = pieceAsObject[\"enPassantable\"]\n  } else {\n    piece.enPassantable = 0\n  }\n\n  if (pieceAsObject.hasOwnProperty(\"hasMoved\")) {\n    piece.hasMoved = pieceAsObject[\"hasMoved\"]\n  } else {\n    piece.hasMoved = false\n  }\n  return piece\n}","import { buildPiece, Piece } from \"./Piece\";\n\nexport type coordinate = [number, number]\n\nexport type move = [coordinate, coordinate, any]\n\nexport type gameprops = {\n  boardState: Piece[][]\n  currPlayer: number,\n  currTurn: number,\n  currWinner: number,\n  updateBoardState: any,\n  sendToSocket: any,\n}\n\nexport const GameState = {\n  LOADING: -1,\n  PLAYER_SELECT: 0,\n  DRAFT: 1,\n  BOARD: 2,\n}\n\nexport const PlayerType = {\n  UNKNOWN: -100,\n  STALEMATE: -99,\n  SPECTATOR: 0,\n  WHITE: 1,\n  BLACK: -1,\n}\n\nexport const PieceType = {\n  INVALID: -100,\n  NONE: 0,\n  WHITE_PAWN: 1,\n  WHITE_KNIGHT: 2,\n  WHITE_BISHOP: 3,\n  WHITE_ROOK: 4,\n  WHITE_QUEEN: 5,\n  WHITE_KING: 6,\n  WHITE_ELEPHANT: 7,\n  BLACK_PAWN: -1,\n  BLACK_KNIGHT: -2,\n  BLACK_BISHOP: -3,\n  BLACK_ROOK: -4,\n  BLACK_QUEEN: -5,\n  BLACK_KING: -6,\n  BLACK_ELEPHANT: -7,\n}\n\nexport function squaresEqual(a: coordinate, b: coordinate) {\n  return a[0] === b[0] && a[1] === b[1]\n}\n\nexport function squaresContainedBy(arr: coordinate[], target: coordinate) {\n  let found = false\n  arr.forEach((elem) => {\n    if (squaresEqual(elem, target)) {\n      found = true\n    }\n  })\n  return found\n}\n\nexport function getPieceAt(coord: coordinate, boardState: any[][]): Piece {\n  if (coord[0] >= 0 && coord[1] >= 0 && coord[0] < 8 && coord[1] < 8) {\n    return boardState[coord[0]][coord[1]]\n  }\n  return buildPiece(PieceType.INVALID)\n}\n\nexport function oppositeSign(a: number, b: number) {\n  if (a === 0 || b === 0) {\n    return true\n  }\n  return a < 0 ? b > 0 : b < 0\n}","export default __webpack_public_path__ + \"static/media/bb.56a2c92d.svg\";","export default __webpack_public_path__ + \"static/media/bn.27a579a3.svg\";","export default __webpack_public_path__ + \"static/media/bp.ad68fd51.svg\";","export default __webpack_public_path__ + \"static/media/bq.ad02b982.svg\";","export default __webpack_public_path__ + \"static/media/bk.58dce528.svg\";","export default __webpack_public_path__ + \"static/media/br.b59b4fc8.svg\";","export default __webpack_public_path__ + \"static/media/wb.7727c6d1.svg\";","export default __webpack_public_path__ + \"static/media/wn.45cb58b5.svg\";","export default __webpack_public_path__ + \"static/media/wp.d372867e.svg\";","export default __webpack_public_path__ + \"static/media/wq.805d8b1e.svg\";","export default __webpack_public_path__ + \"static/media/wk.518bdd4e.svg\";","export default __webpack_public_path__ + \"static/media/wr.db9d31b1.svg\";","export default __webpack_public_path__ + \"static/media/we.74e8df6f.svg\";","export default __webpack_public_path__ + \"static/media/be.8913aa62.svg\";","import { useEffect, useState } from \"react\";\nimport \"./Board.css\";\nimport { PieceType, getPieceAt, oppositeSign, squaresEqual, coordinate, move, gameprops, PlayerType } from \"./Utils\";\nimport { buildPiece, copyPiece, getValidKnightMoves, getValidKingMoves, isSquareUnderAttack, Piece, deserializePiece, serializePiece } from \"./Piece\";\nimport Button from '@material-ui/core/Button';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport BlackBishop from \"./merida_new/bb.svg\"\nimport BlackKnight from \"./merida_new/bn.svg\"\nimport BlackPawn from \"./merida_new/bp.svg\"\nimport BlackQueen from \"./merida_new/bq.svg\"\nimport BlackKing from \"./merida_new/bk.svg\"\nimport BlackRook from \"./merida_new/br.svg\"\nimport WhiteBishop from \"./merida_new/wb.svg\"\nimport WhiteKnight from \"./merida_new/wn.svg\"\nimport WhitePawn from \"./merida_new/wp.svg\"\nimport WhiteQueen from \"./merida_new/wq.svg\"\nimport WhiteKing from \"./merida_new/wk.svg\"\nimport WhiteRook from \"./merida_new/wr.svg\"\nimport WhiteElephant from \"./merida_new/we.svg\"\nimport BlackElephant from \"./merida_new/be.svg\"\n\n\nexport function deserializeBoardState(receivedBoardState: string, currPlayer: number) {\n  const parsed = JSON.parse(receivedBoardState)\n  let boardToReturn: Piece[][] = [[],[],[],[],[],[],[],[]]\n\n  parsed[\"boardState\"].forEach((row: string[], y: number) => {\n    row.forEach((pieceAsString) => {\n      boardToReturn[y].push(deserializePiece(pieceAsString))\n    })\n  })\n\n  if (currPlayer === PlayerType.BLACK) {\n    boardToReturn = flipBoard(boardToReturn)\n  }\n\n  let deserialized: any = {\n    \"boardState\": boardToReturn,\n    \"currTurn\": parsed[\"currTurn\"],\n  }\n  if (parsed.hasOwnProperty(\"winner\")) {\n    deserialized[\"winner\"] = parsed[\"winner\"]\n  }\n\n  return deserialized\n}\n\nexport function serializeBoardState(boardState: Piece[][], currTurn: number, currPlayer: number, checkmate: boolean, stalemate: boolean) {\n  // Serializes a board of Piece objects into a sending JSON string\n  let boardToSerialize = boardState\n  if (currPlayer === PlayerType.BLACK) {\n    boardToSerialize = flipBoard(boardToSerialize)\n  }\n  let serialized: string[][] = [[],[],[],[],[],[],[],[]]\n  boardToSerialize.forEach((row, y) => {\n    row.forEach((elem) => {\n      serialized[y].push(serializePiece(elem))\n    })\n  })\n\n  let data: any = {\n    \"boardState\": serialized,\n    \"currTurn\": currTurn,\n  }\n  if (checkmate) {\n    data[\"winner\"] = currPlayer\n  } else if (stalemate) {\n    data[\"winner\"] = PlayerType.STALEMATE\n  }\n\n  return JSON.stringify(data)\n}\n\nexport function processBoard(board: number[][]) {\n  let res: Piece[][] = []\n  board.forEach((row, y) => {\n    res.push([])\n    row.forEach((elem) => {\n      res[y].push(buildPiece(elem))\n    })\n  })\n  return res\n}\n\nexport function flipBoard(board: Piece[][]) {\n  // Will need to reverse each row and then reverse all the columns\n  return board.slice(0).reverse().map((row) => {\n    return row.slice(0).reverse()\n  })\n}\n\nexport function renderSquare(coord: coordinate, piece: number, selected: boolean, onSelect: any) {\n  \n  function getAsset(piece: number) {\n    switch(piece) {\n      case PieceType.WHITE_ELEPHANT:\n        return WhiteElephant\n      case PieceType.BLACK_ELEPHANT:\n        return BlackElephant\n      case PieceType.BLACK_BISHOP:\n        return BlackBishop\n      case PieceType.BLACK_KING:\n        return BlackKing\n      case PieceType.BLACK_KNIGHT:\n        return BlackKnight\n      case PieceType.BLACK_PAWN:\n        return BlackPawn\n      case PieceType.BLACK_QUEEN:\n        return BlackQueen\n      case PieceType.BLACK_ROOK:\n        return BlackRook\n      case PieceType.WHITE_BISHOP:\n        return WhiteBishop\n      case PieceType.WHITE_KING:\n        return WhiteKing\n      case PieceType.WHITE_KNIGHT:\n        return WhiteKnight\n      case PieceType.WHITE_PAWN:\n        return WhitePawn\n      case PieceType.WHITE_QUEEN:\n        return WhiteQueen\n      case PieceType.WHITE_ROOK:\n        return WhiteRook\n    }\n  }\n\n  return (\n    <div\n      className={`square${selected ? ` selected` : ``}`}\n      key={`${coord[0]}-${coord[1]}`}\n      onClick={()=>{onSelect(coord)}}\n    >\n      <img className=\"piece\" src={getAsset(piece)} />\n    </div>\n  )\n}\n\nfunction makeMove(boardState: Piece[][], oldSquare: coordinate, newSquare: coordinate, extraInfo?: any) {\n  // Build a copy of the board\n  let newBoard: Piece[][] = [[],[],[],[],[],[],[],[]]\n  boardState.forEach((row, y) => {\n    row.forEach((elem) => {\n      newBoard[y].push(copyPiece(elem))\n    })\n  })\n\n  let postMovePieces = []\n\n  if (extraInfo.hasOwnProperty(\"castle\") && extraInfo[\"castle\"]) {\n    const rookPos = extraInfo[\"rookPos\"]\n    const kingPos = extraInfo[\"kingPos\"]\n\n    // King moves two squares in direction of rook\n    const yDiff = rookPos[1] - kingPos[1]\n    const yInc = yDiff > 0 ? 1 : -1\n\n    const newRookPos = [kingPos[0], kingPos[1]+(2*yInc)-(yInc)]\n    const newKingPos = [kingPos[0], kingPos[1]+(2*yInc)]\n\n    newBoard[newKingPos[0]][newKingPos[1]] = getPieceAt(kingPos, newBoard)\n    newBoard[newRookPos[0]][newRookPos[1]] = getPieceAt(rookPos, newBoard)\n\n    postMovePieces.push([kingPos, newKingPos])\n    postMovePieces.push([rookPos, newRookPos])\n\n    newBoard[kingPos[0]][kingPos[1]] = buildPiece(PieceType.NONE)\n    newBoard[rookPos[0]][rookPos[1]] = buildPiece(PieceType.NONE)\n  } else if (extraInfo.hasOwnProperty(\"enpassant\") && extraInfo[\"enpassant\"]) {\n    postMovePieces.push([oldSquare, newSquare])\n\n    newBoard[newSquare[0]][newSquare[1]] = getPieceAt(oldSquare, newBoard)\n    newBoard[oldSquare[0]][oldSquare[1]] = buildPiece(PieceType.NONE)\n  \n    const movedPiece = getPieceAt(newSquare, newBoard)\n    const diff = movedPiece.type === PieceType.WHITE_PAWN ? 1 : -1\n    newBoard[newSquare[0]-diff][newSquare[1]] = buildPiece(0)\n  } else {\n    postMovePieces.push([oldSquare, newSquare])\n\n    newBoard[newSquare[0]][newSquare[1]] = getPieceAt(oldSquare, newBoard)\n    newBoard[oldSquare[0]][oldSquare[1]] = buildPiece(0)\n  }\n\n  /*\n  TODO: Elephant\n  if (extraInfo.hasOwnProperty(\"crush\")) {\n    newBoard[extraInfo[\"crush\"][0]][extraInfo[\"crush\"][1]] = buildPiece(0)\n  }\n  */\n\n  postMovePieces.forEach((elem) => {\n    newBoard[elem[1][0]][elem[1][1]].postMove(elem[0], elem[1], boardState)\n  })\n\n  newBoard.forEach((row, y) => {\n    row.forEach((elem, x) => {\n      elem.turnTick([x,y], newBoard)\n    })\n  })\n\n  return newBoard\n}\n\nfunction Board(props: gameprops) {\n  let { currPlayer, currTurn, currWinner } = props\n\n  const [selectedSquare, setSelectedSquare]: [coordinate, any] = useState([-1,-1])\n  const [displayGameEnd, setDisplayGameEnd] = useState(PlayerType.SPECTATOR)\n\n  useEffect(() => {\n    setDisplayGameEnd(currWinner);\n  }, [currWinner])\n\n  async function updateBoardState(newBoard: Piece[][], checkmate: boolean, stalemate: boolean) {\n    const serialized = serializeBoardState(newBoard, currTurn*-1, currPlayer, checkmate, stalemate)\n\n    if (checkmate) {\n      setDisplayGameEnd(currPlayer)\n    } else if (stalemate) {\n      setDisplayGameEnd(PlayerType.STALEMATE)\n    }\n\n    while (true) {\n      if (props.sendToSocket(serialized)) {\n        props.updateBoardState(newBoard)\n        break\n      }\n      await new Promise(resolve => setTimeout(resolve, 1));\n    }\n  }\n\n  function validateChecks(piece: coordinate, newSquare: coordinate, extraInfo?: any): [boolean, boolean, Piece[][]] {\n    const simulatedBoard = makeMove(props.boardState, piece, newSquare, extraInfo)\n    let opponentKing: coordinate = [-1,-1]\n    let allyKing: coordinate = [-1,-1]\n    // Find both kings\n    simulatedBoard.forEach((row, x) => {\n      row.forEach((elem, y) => {\n        if ([PieceType.BLACK_KING, PieceType.WHITE_KING].includes(elem.type)) {\n          if (oppositeSign(elem.type, currPlayer)) {\n            opponentKing = [x, y]\n          } else {\n            allyKing = [x, y]\n          }\n        }\n      })\n    })\n\n    // A move is valid so long as the player is not in check after the move\n    const playerInCheck = isSquareUnderAttack(allyKing, currPlayer, simulatedBoard)\n    const opponentInCheck = isSquareUnderAttack(opponentKing, -1*currPlayer, simulatedBoard)\n    return [playerInCheck, opponentInCheck, simulatedBoard]\n  }\n\n  function isOpponentMated(boardState: Piece[][]) {\n    let validMoves: move[] = []\n    const cardinalIncs = [\n      [1,0],\n      [0,1],\n      [-1,0],\n      [0,-1]\n    ]\n    const diagonalIncs = [\n      [1,1],\n      [-1,1],\n      [1,-1],\n      [-1,-1]\n    ]\n  \n    boardState.forEach((row, x) => {\n      row.forEach((elem, y) => {\n        if (elem.type !== PieceType.NONE && oppositeSign(currPlayer, elem.type)) {\n          // If the piece is not none and they are the opponents\n          const piecePos: coordinate = [x, y]\n          const candidateNewPos: coordinate[] = []\n          if ([PieceType.BLACK_KING, PieceType.WHITE_KING].includes(elem.type)) {\n            const possibleKingMoves: coordinate[] = getValidKingMoves(piecePos) // Can't castle out of check!\n            possibleKingMoves.forEach((newPos) => {\n              candidateNewPos.push(newPos)\n            })\n          } else if ([PieceType.BLACK_BISHOP, PieceType.WHITE_BISHOP].includes(elem.type)) {\n            diagonalIncs.forEach((increments) => {\n              // Increments is an [xInc, yInc]\n              let xInc = increments[0]\n              let yInc = increments[1]\n              while (Math.abs(xInc) <= 8 && Math.abs(yInc) <= 8) {\n                candidateNewPos.push([x+xInc, y+yInc])\n                xInc += increments[0]\n                yInc += increments[1]\n              }\n            })\n          } else if ([PieceType.BLACK_KNIGHT, PieceType.WHITE_KNIGHT].includes(elem.type)) {\n            const possibleKnightMoves: coordinate[] = getValidKnightMoves(piecePos)\n            possibleKnightMoves.forEach((newPos) => {\n              candidateNewPos.push(newPos)\n            })\n          } else if ([PieceType.BLACK_ROOK, PieceType.WHITE_ROOK].includes(elem.type)) {\n            cardinalIncs.forEach((increments) => {\n              // Increments is an [xInc, yInc]\n              let xInc = increments[0]\n              let yInc = increments[1]\n              while (Math.abs(xInc) <= 8 && Math.abs(yInc) <= 8) {\n                candidateNewPos.push([x+xInc, y+yInc])\n                xInc += increments[0]\n                yInc += increments[1]\n              }\n            })\n          } else if ([PieceType.BLACK_QUEEN, PieceType.WHITE_QUEEN].includes(elem.type)) {\n            diagonalIncs.forEach((increments) => {\n              // Increments is an [xInc, yInc]\n              let xInc = increments[0]\n              let yInc = increments[1]\n              while (Math.abs(xInc) <= 8 && Math.abs(yInc) <= 8) {\n                candidateNewPos.push([x+xInc, y+yInc])\n                xInc += increments[0]\n                yInc += increments[1]\n              }\n            })\n  \n            cardinalIncs.forEach((increments) => {\n              // Increments is an [xInc, yInc]\n              let xInc = increments[0]\n              let yInc = increments[1]\n              while (Math.abs(xInc) <= 8 && Math.abs(yInc) <= 8) {\n                candidateNewPos.push([x+xInc, y+yInc])\n                xInc += increments[0]\n                yInc += increments[1]\n              }\n            })\n          } else if ([PieceType.BLACK_PAWN, PieceType.WHITE_PAWN].includes(elem.type)) {\n            // Opposing pawn\n            candidateNewPos.push([x+1, y])\n            candidateNewPos.push([x+1, y+1])\n            candidateNewPos.push([x+1, y-1])\n          }\n  \n          candidateNewPos.forEach((newPos) => {\n            const validationResult = elem.validateMove([x,y], newPos, boardState)\n            if (validationResult[0]) {\n              validMoves.push([[x,y], newPos, validationResult[1]])\n            }\n          })\n        }\n      })\n    })\n  \n    // Opponent is mated if for every valid move, they are still in check\n    // Check this manually\n    return validMoves.every((elem) => {\n      const simulatedBoard = makeMove(boardState, elem[0], elem[1], elem[2])\n      let opponentKing: coordinate = [-1,-1]\n      simulatedBoard.forEach((row, x) => {\n        row.forEach((elem, y) => {\n          if ([PieceType.BLACK_KING, PieceType.WHITE_KING].includes(elem.type)) {\n            if (oppositeSign(elem.type, currPlayer)) {\n              opponentKing = [x, y]\n            }\n          }\n        })\n      })\n      return isSquareUnderAttack(opponentKing, -1*currPlayer, simulatedBoard)\n    })\n  }\n\n  function selectSquare(newSquare: coordinate) {\n    // 1. Check if there is a currently selected square. If not, select newSquare and done.\n    if (squaresEqual(newSquare, selectedSquare)) {\n      setSelectedSquare([-1, -1])\n      return\n    } else if (squaresEqual(selectedSquare, [-1, -1])) {\n      setSelectedSquare(newSquare)\n      return\n    }\n\n    // 2. If there is a currently selected square, check if there is a piece there. If not, select newSquare and done.\n    const pieceOnSquare: Piece = props.boardState[selectedSquare[0]][selectedSquare[1]]\n    if (pieceOnSquare.type === PieceType.NONE) {\n      setSelectedSquare(newSquare)\n      return\n    }\n\n    const isCurrentTurn = (currTurn === currPlayer)\n    if (isCurrentTurn && !oppositeSign(pieceOnSquare.type, currPlayer)) {\n      // 3. There is a currently selected piece, check if the new selection is a valid move. If not, select newSquare and done.\n      const [isValidMove, extraInfo] = pieceOnSquare.validateMove(selectedSquare, newSquare, props.boardState)\n      if (isValidMove) {\n        // 4. Validate for checks and checkmates\n        const [playerInCheck, opponentInCheck, newBoard] = validateChecks(selectedSquare, newSquare, extraInfo)\n        if (!playerInCheck) {\n          // 5. If the opponent is in check, see if we have a mate\n          const opponentHasNoValidMoves = isOpponentMated(newBoard)\n          updateBoardState(newBoard, opponentInCheck && opponentHasNoValidMoves, !opponentInCheck && opponentHasNoValidMoves)\n          setSelectedSquare([-1, -1])\n          return\n        }\n      }\n    }\n\n    setSelectedSquare(newSquare)\n  }\n\n  const stalemateText = \"Draw by stalemate. No more valid moves.\"\n  const checkmateText = \" has won by checkmate.\"\n\n  return (\n    <div>\n      <Dialog\n        fullWidth={true}\n        open={displayGameEnd !== PlayerType.UNKNOWN}\n        onClose={() => {setDisplayGameEnd(PlayerType.UNKNOWN)}}\n        aria-labelledby=\"alert-dialog-title\"\n        aria-describedby=\"alert-dialog-description\"\n      >\n        <DialogTitle>\n          <span className=\"game-over-text\">\n            {displayGameEnd === PlayerType.STALEMATE ? stalemateText : (displayGameEnd === PlayerType.WHITE ? \"White\" : \"Black\") + checkmateText}\n          </span>\n        </DialogTitle>\n        <DialogActions>\n          <Button onClick={() => {setDisplayGameEnd(PlayerType.UNKNOWN)}}>\n            GG!\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <div className=\"board\">\n        {props.boardState.map(\n          (row, x) => (\n            <div className=\"row\" key={x}>\n              {row.map((occupant, y) => renderSquare(\n                [x,y],\n                occupant.type,\n                squaresEqual(selectedSquare, [x,y]),\n                selectSquare,\n              ))}\n            </div>\n          )\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default Board;\n","import \"./Draft.css\";\nimport React, { useState } from \"react\";\nimport { coordinate, PieceType, PlayerType, squaresContainedBy, squaresEqual } from \"./Utils\";\nimport { renderSquare } from \"./Board\";\nimport Button from '@material-ui/core/Button';\n\nconst emptyWhiteDraft = [\n  [0,0,0,1,1,1,0,0],\n  [0,0,0,0,6,0,0,0],\n]\n\nconst emptyBlackDraft = [\n  [0,0,-1,-1,-1,0,0,0],\n  [0,0,0,-6,0,0,0,0],\n]\n\nconst pointTotal = 36\n\nconst whiteIllegalSquares: coordinate[] = [[0,3], [0,4], [0,5], [1,4]]\nconst blackIllegalSquares: coordinate[] = [[0,2], [0,3], [0,4], [1,3]]\n\nconst bishopSquares: coordinate[] = [[1,2], [1,5]]\nconst knightSquares: coordinate[] = [[1,1], [1,6]]\nconst whiteQueenSquare: coordinate = [1,3]\nconst blackQueenSquare: coordinate = [1,4]\nconst rookSquares: coordinate[] = [[1,0], [1,7]]\n\nconst rookPieces: number[] = [PieceType.NONE, PieceType.WHITE_ROOK]\nconst bishopPieces: number[] = [PieceType.NONE, PieceType.WHITE_BISHOP]\nconst knightPieces: number[] = [PieceType.NONE, PieceType.WHITE_KNIGHT]\nconst queenPieces: number[] = [PieceType.NONE, PieceType.WHITE_QUEEN]\nconst pawnPieces: number[] = [PieceType.NONE, PieceType.WHITE_PAWN]\n\nconst allPieces: number[] = [\n  PieceType.NONE,\n  PieceType.WHITE_ROOK,\n  PieceType.WHITE_BISHOP,\n  PieceType.WHITE_KNIGHT,\n  PieceType.WHITE_QUEEN,\n  PieceType.WHITE_PAWN,\n]\n\nfunction pieceToPoints(piece: number) {\n  switch(piece) {\n    case PieceType.BLACK_BISHOP:\n      return 3\n    case PieceType.BLACK_KING:\n      return 0\n    case PieceType.BLACK_KNIGHT:\n      return 3\n    case PieceType.BLACK_PAWN:\n      return 1\n    case PieceType.BLACK_QUEEN:\n      return 9\n    case PieceType.BLACK_ROOK:\n      return 5\n    case PieceType.WHITE_BISHOP:\n      return 3\n    case PieceType.WHITE_KING:\n      return 0\n    case PieceType.WHITE_KNIGHT:\n      return 3\n    case PieceType.WHITE_PAWN:\n      return 1\n    case PieceType.WHITE_QUEEN:\n      return 9\n    case PieceType.WHITE_ROOK:\n      return 5\n    case PieceType.WHITE_ELEPHANT:\n      return 7\n    case PieceType.BLACK_ELEPHANT:\n      return 7\n  }\n  return 0\n}\n\nfunction Draft(props: any) {\n  let { currPlayer, submitDraft } = props\n  const [currDraft, setCurrDraft]: [number[][], any] = useState(currPlayer === PlayerType.BLACK ? emptyBlackDraft : emptyWhiteDraft)\n  const [currPoints, setPoints]: [number, any] = useState(pointTotal)\n  const [selectedSquare, setSelectedSquare]: [coordinate, any] = useState([-1,-1])\n\n  function selectSquare(newSquare: coordinate) {\n    if (currPlayer === PlayerType.SPECTATOR) {\n      return\n    }\n    // 1. Check if there is a currently selected square. If not, select newSquare and done.\n    if (squaresEqual(newSquare, selectedSquare)) {\n      setSelectedSquare([-1, -1])\n      return\n    }\n\n    setSelectedSquare(newSquare)\n  }\n\n  function availablePieces() {\n    // Balance-wise, I'm not sure how broken it is to restrict draft pieces to a square...\n    // If I need to rebalance the game, here is where we can configure the possible drafts\n    if (\n      squaresEqual(selectedSquare, [-1, -1])\n      || (currPlayer === PlayerType.WHITE && squaresContainedBy(whiteIllegalSquares, selectedSquare))\n      || (currPlayer === PlayerType.BLACK && squaresContainedBy(blackIllegalSquares, selectedSquare))\n    ) {\n      return []\n    }\n    let res = allPieces\n\n    /*\n    TODO: Square-constrained drafts\n    let res: number[] = []\n\n    if (selectedSquare[0] === 0) {\n      res = pawnPieces\n    } else if (currPlayer === PlayerType.WHITE && squaresEqual(selectedSquare, whiteQueenSquare)) {\n      res = queenPieces\n    } else if (currPlayer === PlayerType.BLACK && squaresEqual(selectedSquare, blackQueenSquare)) {\n      res = queenPieces\n    } else if (squaresContainedBy(rookSquares, selectedSquare)) {\n      res = rookPieces\n    } else if (squaresContainedBy(bishopSquares, selectedSquare)) {\n      res = bishopPieces\n    } else if (squaresContainedBy(knightSquares, selectedSquare)) {\n      res = knightPieces\n    }\n    */\n\n    return res.map((elem) => currPlayer*elem)\n  }\n\n  function draftPiece(piece: number) {\n    let newDraft: number[][] = [[],[]]\n    let newPointTotal = pointTotal\n    currDraft.forEach((row, y) => {\n      row.forEach((elem, x) => {\n        if (squaresEqual(selectedSquare, [y,x])) {\n          newDraft[y].push(piece)\n          newPointTotal -= pieceToPoints(piece)\n        } else {\n          newDraft[y].push(elem)\n          newPointTotal -= pieceToPoints(elem)\n        }\n      })\n    })\n\n    setCurrDraft(newDraft)\n    setPoints(newPointTotal)\n  }\n\n  return (\n    <div className=\"draft\">\n      <div className=\"draft-board\">\n        {currDraft.map(\n          (row, x) => (\n            <div className=\"row\" key={x}>\n              {row.map((occupant, y) => renderSquare(\n                [x,y],\n                occupant,\n                squaresEqual(selectedSquare, [x,y]),\n                selectSquare,\n              ))}\n            </div>\n          )\n        )}\n      </div>\n      <div className=\"available-pieces\">\n        <div className=\"row\">\n          {availablePieces().map(\n            (piece, idx) => {\n              return renderSquare(\n                [-1,idx],\n                piece,\n                squaresEqual(selectedSquare, [-1,idx]),\n                () => {draftPiece(piece)},\n              )\n            }\n          )}\n        </div>\n      </div>\n\n      <div className=\"points-and-submit\">\n        <div className=\"points\"><strong>{currPoints}</strong></div>\n        <Button variant=\"contained\" size=\"large\" disabled={currPlayer === PlayerType.SPECTATOR} onClick={() => submitDraft(currDraft, currPoints)}>\n          <span className=\"button-text\">Submit draft</span>\n        </Button>\n      </div>\n\n      <br/>\n\n      <div className=\"info\">\n        <p>\n          This is the draft phase. Here, you can configure your board in the interface above before squaring off against\n          your opponent.\n        </p>\n\n        <p>\n          Select a square to see what pieces are possible to be drafted there. Hit Submit when you're done. When both you and your opponent\n          have submitted drafts, you'll automatically be brought into the game phase.\n        </p>\n\n        <p>\n          A few ground rules here:\n          <ul>\n            <li><strong>The king and the three pawns ahead of it cannot be moved.</strong> This rule was added to prevent instant checkmate cheeses.</li>\n            <li><strong>A draft is valid if and only if it has a point total greater than or equal to 0</strong></li>\n          </ul>\n        </p>\n      </div>\n    </div>\n  )\n}\n\nexport default Draft;","import axios from \"axios\";\nimport React, { useEffect, useState } from \"react\";\nimport { useCookies } from \"react-cookie\";\nimport { useLocation } from \"react-router-dom\";\nimport { PlayerType, GameState } from \"./Utils\";\nimport Board from \"./Board\";\nimport { deserializeBoardState, flipBoard, processBoard } from \"./Board\";\nimport Draft from \"./Draft\";\nimport { serializePiece, Piece } from \"./Piece\";\n\nimport \"./Board.css\";\n\nconst startingBoard = [\n  [-4,-2,-3,-5,-6,-3,-2,-4],\n  [-1,-1,-1,-1,-1,-1,-1,-1],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [1,1,1,1,1,1,1,1],\n  [4,2,3,5,6,3,2,4]\n]\n\nconst emptyBoard = [\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0,0]\n]\n\nfunction Game() {\n  // Game will handle all the extra tinkering:\n  // 1. Selecting players (remembering with cookies)\n  // 2. Initializing the websocket\n  // 3. Displaying the select/waiting, the draft, the board\n\n  const [cookies, setCookie, removeCookie] = useCookies([\"chess-dlc\"]);\n  const [gameInfo, setGameInfo] = useState({\n    gameId: useLocation().pathname.split(\"/\").pop(),\n    gameState: GameState.LOADING,\n    currPlayer: PlayerType.UNKNOWN,\n    currTurn: PlayerType.WHITE,\n    currWinner: PlayerType.UNKNOWN,\n    boardState: processBoard(startingBoard),\n  });\n  const [webSocket, setWebSocket]: [any, any] = useState(null)\n\n  useEffect(() => {\n    // 1. Try to join the game, handle the cases:\n    // a) Client has a cookie so they've already joined\n    // b) Client has no cookie, game needs a player\n    // c) Joining as a spectator\n    const cookiePresent = cookies.hasOwnProperty(\"chess-dlc\") && cookies[\"chess-dlc\"].hasOwnProperty(\"player\")\n    axios.get(`/join/${gameInfo.gameId}`, {params: {cookiePresent: cookiePresent}}).then(res => {\n      let currPlayer = PlayerType.SPECTATOR\n      if (cookiePresent) {\n        // Client has already joined before\n        currPlayer = cookies[\"chess-dlc\"][\"player\"]\n      } else if (res.data.timesJoined <= 2) {\n        // Accepting a new player\n        currPlayer = res.data.waitingFor\n\n        setCookie(\n          \"chess-dlc\",\n          {\"player\": res.data.waitingFor, \"gameId\": gameInfo.gameId},\n          {path: `/game/${gameInfo.gameId}`, maxAge: 3600*24*3},\n        );\n      }\n\n      if (res.data.board) {\n        const receivedBoardState = deserializeBoardState(res.data.board, currPlayer)\n        setGameInfo({\n          ...gameInfo,\n          currPlayer: currPlayer,\n          gameId: gameInfo.gameId,\n          gameState: res.data.gameState,\n          boardState: receivedBoardState.boardState,\n          currTurn: receivedBoardState.currTurn,\n          currWinner: receivedBoardState.hasOwnProperty(\"winner\") ? receivedBoardState.winner : PlayerType.UNKNOWN,\n        })\n      } else {\n        // Case happens when game starts and there's no board on Firebase\n        setGameInfo({\n          ...gameInfo,\n          currPlayer: currPlayer,\n          gameId: gameInfo.gameId,\n          gameState: res.data.gameState,\n          currTurn: PlayerType.WHITE,\n        })\n      }\n\n      // 2. Load up the websocket\n      const l = window.location;\n      let websocketUrl = ((l.protocol === \"https:\") ? \"wss://\" : \"ws://\") + l.host + `/websocket/${gameInfo.gameId}`;\n\n      let ws = new WebSocket(websocketUrl)\n      ws.onopen = () => {\n        setWebSocket(ws)\n      };\n\n      // Since event handlers are defined once, the values they \"know\"\n      // are the values at the time of their definition.\n      // We use a new => function as a way to get the \"fresh\" state\n      ws.onmessage = (event) => {\n        // TODO: Enter draft stage\n        setGameInfo((gameInfo) => {\n          const receivedBoardState = deserializeBoardState(event.data, gameInfo.currPlayer)\n          console.log(receivedBoardState)\n          const updatedGameInfo = {\n            ...gameInfo,\n            gameState: GameState.BOARD, // By the time we receive stuff from the websocket, should be in game\n            boardState: receivedBoardState.boardState,\n            currTurn: receivedBoardState.currTurn,\n            currWinner: receivedBoardState.hasOwnProperty(\"winner\") ? receivedBoardState.winner : PlayerType.UNKNOWN,\n          }\n          console.log(updatedGameInfo)\n          return updatedGameInfo\n        })\n      }\n    })\n  }, []);\n\n  function sendToSocket(data: string) {\n    if (webSocket === null || webSocket.readyState !== 1) {\n      return false\n    } else {\n      webSocket.send(data)\n      return true\n    }\n  }\n\n  function submitDraft(currDraft: number[][], currPoints: number) {\n    if (currPoints < 0) {\n      // Illegal board\n      return\n    }\n\n    // Submit the draft to the backend\n    let processedCurrDraft = processBoard(currDraft)\n  \n    let draftToSerialize = processedCurrDraft\n    if (gameInfo.currPlayer === PlayerType.BLACK) {\n      draftToSerialize = flipBoard(draftToSerialize)\n    }\n    let serialized: string[][] = []\n    draftToSerialize.forEach((row, y) => {\n      serialized.push([])\n      row.forEach((elem) => {\n        serialized[y].push(serializePiece(elem))\n      })\n    })\n\n    const stringified = JSON.stringify(serialized)\n    axios.post(\n      `/draft/${gameInfo.gameId}`,\n      {\"currPlayer\": gameInfo.currPlayer, \"draft\": stringified.substring(1, stringified.length-1)},\n    )\n  }\n\n  function updateBoardState(newBoard: Piece[][]) {\n    setGameInfo({\n      ...gameInfo,\n      currTurn: -1*gameInfo.currTurn,\n      boardState: newBoard,\n    }) \n  }\n\n  if (gameInfo.gameState === GameState.LOADING) {\n    return <div>Loading...</div>\n    // TODO: Debugging\n  } else if (gameInfo.gameState === GameState.DRAFT || gameInfo.gameState === GameState.PLAYER_SELECT) {\n    return (\n      <Draft\n        currPlayer={gameInfo.currPlayer}\n        submitDraft={submitDraft}\n      />\n    )\n  } else {\n    // Both player select and game use the board\n    return (\n      <Board\n        boardState={gameInfo.boardState}\n        currPlayer={gameInfo.currPlayer}\n        currTurn={gameInfo.currTurn}\n        currWinner={gameInfo.currWinner}\n        sendToSocket={sendToSocket}\n        updateBoardState={updateBoardState}\n      />\n    )\n  }\n\n}\n\nexport default Game;","import { useHistory } from \"react-router-dom\";\nimport { PlayerType } from \"./Utils\";\nimport Button from '@material-ui/core/Button';\nimport \"./Lobby.css\";\n\nfunction Lobby(props: any) {\n  const { createGame } = props\n  const history = useHistory()\n\n  return (\n    <div className=\"lobby\">\n      <div className=\"info\">\n        <p>\n          <strong>Draft Chess <span style={{\"fontSize\": \"15px\"}}>(the name is a WIP)</span></strong>\n        </p>\n\n        <p>\n          This is a simple web client for an experimental <a href=\"https://en.wikipedia.org/wiki/Chess_variant\">chess variant</a> based on the concept of \n          \"drafting a board\". Each game has two phases:\n          <ul>\n            <li><strong>Draft:</strong> Where players draft pieces to build out their initial board</li>\n            <li><strong>Game:</strong> Where players play out a game of chess using the board they drafted</li>\n          </ul>\n        </p>\n\n        <p>\n          <strong>How to start:</strong> To start a game, simply click the buttons to be redirected to a generated room. Send the URL for the room to a friend \n          and the first visitor will play with you.\n        </p>\n\n        <p>\n          <strong>Disclaimer:</strong> This variant is a work in progress! The primary purpose of this app is for me to have a \"playtesting\" area to figure out what's\n          fun and what's not - as such, the rules are subject to change at my whim.\n        </p>\n\n        <p><a href=\"https://github.com/xcjackpan/chess_dlc\">Here's the source code if you're a nerd</a></p>\n      </div>\n      <div className=\"buttons\">\n        <Button variant=\"contained\" size=\"large\" onClick={() => {createGame(history, PlayerType.WHITE)}}>\n          <span className=\"button-text\">Create game as white</span>\n        </Button>\n        <Button variant=\"contained\" size=\"large\" onClick={() => {createGame(history, PlayerType.BLACK)}}>\n          <span className=\"button-text\">Create game as black</span>\n        </Button>\n      </div>\n    </div>\n  )\n}\n\nexport default Lobby;","import axios from \"axios\";\nimport React, { useState } from \"react\";\nimport { CookiesProvider } from \"react-cookie\";\nimport { HashRouter, Route, Switch } from \"react-router-dom\";\nimport Game from \"./Game\";\nimport Lobby from \"./Lobby\";\n\nfunction App() {\n  const [isLoading, setIsLoading] = useState(false);\n\n  function createGame(history: any, createdBy: number) {\n    // 1. Create the record of the game in the backend\n    axios.post(\"/create\", {\"createdBy\": createdBy}).then(res => {\n      const gameInfo = res.data\n\n      // 2. Redirect you to the game\n      history.push(`/game/${gameInfo.gameId}`)\n    });\n  }\n\n  if (isLoading) {\n    return (\n      <div className=\"main\">\n        <div>Loading</div>\n      </div>\n    );\n  } else {\n    return (\n      <CookiesProvider>\n        <HashRouter>\n          <Switch>\n            <Route\n              path=\"/game/:gameId\"\n              render={() => (\n                <div className=\"main\">\n                  <Game />\n                </div>\n              )}\n            />\n            <Route\n              render={() => (\n                <div className=\"main\">\n                  <Lobby\n                    createGame={createGame}\n                  />\n                </div>\n              )}\n            />\n          </Switch>\n        </HashRouter>\n      </CookiesProvider>\n    )\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App.tsx';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}